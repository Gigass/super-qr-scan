{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\n/**\n * 二维码检测工具模块\n * 使用 OpenCV.js 的 QRCodeDetector.detect() 方法检测二维码位置\n */\n\n/* global cv */\n\n// OpenCV.js 加载状态\nlet cvReady = false;\nlet cvLoadPromise = null;\n\n/**\n * 动态加载 OpenCV.js\n * @returns {Promise<void>}\n */\nfunction loadOpenCV() {\n  if (cvReady) {\n    return Promise.resolve();\n  }\n  if (cvLoadPromise) {\n    return cvLoadPromise;\n  }\n  cvLoadPromise = new Promise((resolve, reject) => {\n    // 检查是否已经加载\n    if (typeof cv !== 'undefined' && cv.Mat) {\n      cvReady = true;\n      resolve();\n      return;\n    }\n\n    // 创建 script 标签加载 OpenCV.js\n    const script = document.createElement('script');\n    script.src = 'https://docs.opencv.org/4.8.0/opencv.js';\n    script.async = true;\n\n    // OpenCV.js 加载完成后会调用 onRuntimeInitialized\n    window.Module = {\n      onRuntimeInitialized() {\n        console.log('OpenCV.js 已加载');\n        cvReady = true;\n        resolve();\n      }\n    };\n    script.onerror = () => {\n      reject(new Error('OpenCV.js 加载失败'));\n    };\n\n    // 设置超时\n    const timeout = setTimeout(() => {\n      if (!cvReady) {\n        reject(new Error('OpenCV.js 加载超时'));\n      }\n    }, 30000);\n\n    // 监听 cv 对象就绪\n    const checkReady = setInterval(() => {\n      if (typeof cv !== 'undefined' && cv.Mat) {\n        clearInterval(checkReady);\n        clearTimeout(timeout);\n        cvReady = true;\n        resolve();\n      }\n    }, 100);\n    document.head.appendChild(script);\n  });\n  return cvLoadPromise;\n}\n\n/**\n * 图像预处理：对比度增强\n */\nfunction enhanceContrast(gray) {\n  const result = new cv.Mat();\n  // CLAHE 对比度受限的自适应直方图均衡化\n  const clahe = new cv.CLAHE(2.0, new cv.Size(8, 8));\n  clahe.apply(gray, result);\n  clahe.delete();\n  return result;\n}\n\n/**\n * 图像预处理：自适应二值化\n */\nfunction adaptiveThreshold(gray) {\n  const result = new cv.Mat();\n  cv.adaptiveThreshold(gray, result, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 11, 2);\n  return result;\n}\n\n/**\n * 图像预处理：放大\n */\nfunction scaleUp(gray, factor) {\n  const result = new cv.Mat();\n  const newSize = new cv.Size(gray.cols * factor, gray.rows * factor);\n  cv.resize(gray, result, newSize, 0, 0, cv.INTER_CUBIC);\n  return result;\n}\n\n/**\n * 图像预处理：锐化\n */\nfunction sharpen(gray) {\n  const result = new cv.Mat();\n  const kernel = cv.matFromArray(3, 3, cv.CV_32F, [0, -1, 0, -1, 5, -1, 0, -1, 0]);\n  cv.filter2D(gray, result, -1, kernel);\n  kernel.delete();\n  return result;\n}\n\n/**\n * 检测图像中的二维码位置\n * @param {ImageData} imageData - Canvas 的 ImageData 对象\n * @returns {Promise<Object|null>} 检测结果，包含位置信息\n */\nexport async function detectQRCode(imageData) {\n  const matsToDelete = []; // 统一管理需要释放的 Mat\n\n  try {\n    console.log('[QR检测] 开始检测...');\n    console.log('[QR检测] 图像尺寸:', imageData.width, 'x', imageData.height);\n\n    // 确保 OpenCV.js 已加载\n    await loadOpenCV();\n    console.log('[QR检测] OpenCV.js 已就绪');\n\n    // 将 ImageData 转换为 OpenCV Mat\n    const src = cv.matFromImageData(imageData);\n    matsToDelete.push(src);\n    console.log('[QR检测] 原始图像 Mat 创建成功');\n\n    // 转换为灰度图\n    const gray = new cv.Mat();\n    matsToDelete.push(gray);\n    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);\n    console.log('[QR检测] 灰度图转换完成');\n\n    // 创建 QR 码检测器\n    const detector = new cv.QRCodeDetector();\n\n    // 定义多种检测策略\n    const strategies = [{\n      name: '原图直接检测',\n      scale: 1,\n      process: null\n    }, {\n      name: '锐化',\n      scale: 1,\n      process: 'sharpen'\n    }, {\n      name: '自适应二值化',\n      scale: 1,\n      process: 'threshold'\n    }, {\n      name: '放大2倍',\n      scale: 2,\n      process: null\n    }, {\n      name: '放大2倍+锐化',\n      scale: 2,\n      process: 'sharpen'\n    }, {\n      name: '放大3倍',\n      scale: 3,\n      process: null\n    }, {\n      name: '放大4倍',\n      scale: 4,\n      process: null\n    }];\n    let result = null;\n    for (const strategy of strategies) {\n      console.log(`[QR检测] 尝试策略: ${strategy.name}`);\n      let processed = gray;\n\n      // 放大处理\n      if (strategy.scale > 1) {\n        processed = scaleUp(processed, strategy.scale);\n        matsToDelete.push(processed);\n      }\n\n      // 额外处理\n      if (strategy.process === 'sharpen') {\n        const sharpened = sharpen(processed);\n        matsToDelete.push(sharpened);\n        processed = sharpened;\n      } else if (strategy.process === 'threshold') {\n        const thresholded = adaptiveThreshold(processed);\n        matsToDelete.push(thresholded);\n        processed = thresholded;\n      }\n      const points = new cv.Mat();\n      matsToDelete.push(points);\n      const found = detector.detect(processed, points);\n      console.log(`[QR检测] ${strategy.name} - found:`, found, ', points:', points.rows, 'x', points.cols);\n      if (found && points.rows > 0 && points.data32F && points.data32F.length >= 8) {\n        const data = points.data32F;\n        console.log('[QR检测] ✓ 检测到二维码!');\n        console.log('[QR检测] 点数据:', Array.from(data).map(v => Math.round(v)));\n\n        // 根据缩放因子调整坐标\n        const scale = strategy.scale;\n\n        // 四个角点：左上、右上、右下、左下（顺时针）\n        const topLeft = {\n          x: data[0] / scale,\n          y: data[1] / scale\n        };\n        const topRight = {\n          x: data[2] / scale,\n          y: data[3] / scale\n        };\n        const bottomRight = {\n          x: data[4] / scale,\n          y: data[5] / scale\n        };\n        const bottomLeft = {\n          x: data[6] / scale,\n          y: data[7] / scale\n        };\n        const corners = {\n          topLeft,\n          topRight,\n          bottomRight,\n          bottomLeft\n        };\n        result = {\n          topLeft,\n          topRight,\n          bottomRight,\n          bottomLeft,\n          boundingBox: calculateBoundingBox(corners),\n          center: calculateCenter(corners),\n          strategy: strategy.name,\n          allDetections: [{\n            topLeft,\n            topRight,\n            bottomRight,\n            bottomLeft,\n            boundingBox: calculateBoundingBox(corners),\n            center: calculateCenter(corners)\n          }]\n        };\n\n        // 找到就退出循环\n        break;\n      }\n    }\n    detector.delete();\n    if (!result) {\n      console.log('[QR检测] ✗ 所有策略都未检测到二维码');\n    } else {\n      console.log('[QR检测] 检测完成, 使用策略:', result.strategy);\n    }\n    return result;\n  } catch (error) {\n    console.error('[QR检测] OpenCV 检测错误:', error);\n    console.error('[QR检测] 错误堆栈:', error.stack);\n    return null;\n  } finally {\n    // 清理所有 Mat 对象\n    matsToDelete.forEach(mat => {\n      try {\n        if (mat && !mat.isDeleted()) {\n          mat.delete();\n        }\n      } catch (e) {\n        // 忽略删除错误\n      }\n    });\n  }\n}\n\n/**\n * 计算边界框\n * @param {Object} corners - 四个角点坐标\n * @returns {Object} 边界框 { x, y, width, height }\n */\nfunction calculateBoundingBox(corners) {\n  const {\n    topLeft,\n    topRight,\n    bottomRight,\n    bottomLeft\n  } = corners;\n  const points = [topLeft, topRight, bottomRight, bottomLeft];\n  const xs = points.map(p => p.x);\n  const ys = points.map(p => p.y);\n  const minX = Math.min(...xs);\n  const maxX = Math.max(...xs);\n  const minY = Math.min(...ys);\n  const maxY = Math.max(...ys);\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\n\n/**\n * 计算二维码中心点\n * @param {Object} corners - 四个角点坐标\n * @returns {Object} 中心点坐标 { x, y }\n */\nfunction calculateCenter(corners) {\n  const {\n    topLeft,\n    topRight,\n    bottomRight,\n    bottomLeft\n  } = corners;\n  return {\n    x: (topLeft.x + topRight.x + bottomRight.x + bottomLeft.x) / 4,\n    y: (topLeft.y + topRight.y + bottomRight.y + bottomLeft.y) / 4\n  };\n}\n\n/**\n * 在 Canvas 上绘制检测结果\n * @param {CanvasRenderingContext2D} ctx - Canvas 2D 上下文\n * @param {Object} detection - 检测结果\n * @param {Object} options - 绘制选项\n */\nexport function drawDetectionResult(ctx, detection, options = {}) {\n  const {\n    fillColor = 'rgba(0, 245, 160, 0.15)',\n    lineWidth = 3,\n    cornerRadius = 8,\n    showCenter = true,\n    showCorners = true\n  } = options;\n\n  // 绘制所有检测到的二维码\n  const detections = detection.allDetections || [detection];\n  detections.forEach((det, index) => {\n    const {\n      topLeft,\n      topRight,\n      bottomRight,\n      bottomLeft,\n      center\n    } = det;\n\n    // 不同二维码用不同颜色\n    const colors = ['#00f5a0', '#ff6b6b', '#4ecdc4', '#ffe66d', '#a855f7'];\n    const color = colors[index % colors.length];\n    ctx.save();\n\n    // 绘制填充区域\n    ctx.fillStyle = fillColor;\n    ctx.beginPath();\n    ctx.moveTo(topLeft.x, topLeft.y);\n    ctx.lineTo(topRight.x, topRight.y);\n    ctx.lineTo(bottomRight.x, bottomRight.y);\n    ctx.lineTo(bottomLeft.x, bottomLeft.y);\n    ctx.closePath();\n    ctx.fill();\n\n    // 绘制边框\n    ctx.strokeStyle = color;\n    ctx.lineWidth = lineWidth;\n    ctx.lineCap = 'round';\n    ctx.lineJoin = 'round';\n\n    // 绘制四边形边框\n    ctx.beginPath();\n    ctx.moveTo(topLeft.x, topLeft.y);\n    ctx.lineTo(topRight.x, topRight.y);\n    ctx.lineTo(bottomRight.x, bottomRight.y);\n    ctx.lineTo(bottomLeft.x, bottomLeft.y);\n    ctx.closePath();\n    ctx.stroke();\n\n    // 绘制角点标记\n    if (showCorners) {\n      const corners = [topLeft, topRight, bottomRight, bottomLeft];\n      ctx.fillStyle = color;\n      corners.forEach(corner => {\n        ctx.beginPath();\n        ctx.arc(corner.x, corner.y, cornerRadius, 0, Math.PI * 2);\n        ctx.fill();\n      });\n    }\n\n    // 绘制中心点\n    if (showCenter) {\n      ctx.fillStyle = color;\n      ctx.beginPath();\n      ctx.arc(center.x, center.y, 6, 0, Math.PI * 2);\n      ctx.fill();\n\n      // 绘制十字线\n      ctx.strokeStyle = color;\n      ctx.lineWidth = 2;\n      const crossSize = 15;\n      ctx.beginPath();\n      ctx.moveTo(center.x - crossSize, center.y);\n      ctx.lineTo(center.x + crossSize, center.y);\n      ctx.moveTo(center.x, center.y - crossSize);\n      ctx.lineTo(center.x, center.y + crossSize);\n      ctx.stroke();\n    }\n    ctx.restore();\n  });\n}\n\n/**\n * 从视频帧获取 ImageData\n * @param {HTMLVideoElement} video - 视频元素\n * @param {HTMLCanvasElement} canvas - Canvas 元素\n * @returns {ImageData|null} ImageData 对象\n */\nexport function getImageDataFromVideo(video, canvas) {\n  if (!video || video.readyState !== video.HAVE_ENOUGH_DATA) {\n    return null;\n  }\n  const ctx = canvas.getContext('2d');\n  canvas.width = video.videoWidth;\n  canvas.height = video.videoHeight;\n  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n  return ctx.getImageData(0, 0, canvas.width, canvas.height);\n}\n\n/**\n * 从图片文件获取 ImageData\n * @param {File} file - 图片文件\n * @returns {Promise<{imageData: ImageData, width: number, height: number}>}\n */\nexport function getImageDataFromFile(file) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = e => {\n      const img = new Image();\n      img.onload = () => {\n        const canvas = document.createElement('canvas');\n        canvas.width = img.width;\n        canvas.height = img.height;\n        const ctx = canvas.getContext('2d');\n        ctx.drawImage(img, 0, 0);\n        const imageData = ctx.getImageData(0, 0, img.width, img.height);\n        resolve({\n          imageData,\n          width: img.width,\n          height: img.height,\n          imageSrc: e.target.result\n        });\n      };\n      img.onerror = () => reject(new Error('图片加载失败'));\n      img.src = e.target.result;\n    };\n    reader.onerror = () => reject(new Error('文件读取失败'));\n    reader.readAsDataURL(file);\n  });\n}\n\n/**\n * 预加载 OpenCV.js（可在应用启动时调用）\n * @returns {Promise<void>}\n */\nexport async function preloadOpenCV() {\n  return loadOpenCV();\n}\n\n/**\n * 检查 OpenCV.js 是否已加载\n * @returns {boolean}\n */\nexport function isOpenCVReady() {\n  return cvReady;\n}","map":{"version":3,"names":["cvReady","cvLoadPromise","loadOpenCV","Promise","resolve","reject","cv","Mat","script","document","createElement","src","async","window","Module","onRuntimeInitialized","console","log","onerror","Error","timeout","setTimeout","checkReady","setInterval","clearInterval","clearTimeout","head","appendChild","enhanceContrast","gray","result","clahe","CLAHE","Size","apply","delete","adaptiveThreshold","ADAPTIVE_THRESH_GAUSSIAN_C","THRESH_BINARY","scaleUp","factor","newSize","cols","rows","resize","INTER_CUBIC","sharpen","kernel","matFromArray","CV_32F","filter2D","detectQRCode","imageData","matsToDelete","width","height","matFromImageData","push","cvtColor","COLOR_RGBA2GRAY","detector","QRCodeDetector","strategies","name","scale","process","strategy","processed","sharpened","thresholded","points","found","detect","data32F","length","data","Array","from","map","v","Math","round","topLeft","x","y","topRight","bottomRight","bottomLeft","corners","boundingBox","calculateBoundingBox","center","calculateCenter","allDetections","error","stack","forEach","mat","isDeleted","e","xs","p","ys","minX","min","maxX","max","minY","maxY","drawDetectionResult","ctx","detection","options","fillColor","lineWidth","cornerRadius","showCenter","showCorners","detections","det","index","colors","color","save","fillStyle","beginPath","moveTo","lineTo","closePath","fill","strokeStyle","lineCap","lineJoin","stroke","corner","arc","PI","crossSize","restore","getImageDataFromVideo","video","canvas","readyState","HAVE_ENOUGH_DATA","getContext","videoWidth","videoHeight","drawImage","getImageData","getImageDataFromFile","file","reader","FileReader","onload","img","Image","imageSrc","target","readAsDataURL","preloadOpenCV","isOpenCVReady"],"sources":["/Users/gigass/DEVELOP/GitHub/qrcode/src/utils/qrDetector.js"],"sourcesContent":["/**\n * 二维码检测工具模块\n * 使用 OpenCV.js 的 QRCodeDetector.detect() 方法检测二维码位置\n */\n\n/* global cv */\n\n// OpenCV.js 加载状态\nlet cvReady = false\nlet cvLoadPromise = null\n\n/**\n * 动态加载 OpenCV.js\n * @returns {Promise<void>}\n */\nfunction loadOpenCV() {\n  if (cvReady) {\n    return Promise.resolve()\n  }\n  \n  if (cvLoadPromise) {\n    return cvLoadPromise\n  }\n  \n  cvLoadPromise = new Promise((resolve, reject) => {\n    // 检查是否已经加载\n    if (typeof cv !== 'undefined' && cv.Mat) {\n      cvReady = true\n      resolve()\n      return\n    }\n    \n    // 创建 script 标签加载 OpenCV.js\n    const script = document.createElement('script')\n    script.src = 'https://docs.opencv.org/4.8.0/opencv.js'\n    script.async = true\n    \n    // OpenCV.js 加载完成后会调用 onRuntimeInitialized\n    window.Module = {\n      onRuntimeInitialized() {\n        console.log('OpenCV.js 已加载')\n        cvReady = true\n        resolve()\n      }\n    }\n    \n    script.onerror = () => {\n      reject(new Error('OpenCV.js 加载失败'))\n    }\n    \n    // 设置超时\n    const timeout = setTimeout(() => {\n      if (!cvReady) {\n        reject(new Error('OpenCV.js 加载超时'))\n      }\n    }, 30000)\n    \n    // 监听 cv 对象就绪\n    const checkReady = setInterval(() => {\n      if (typeof cv !== 'undefined' && cv.Mat) {\n        clearInterval(checkReady)\n        clearTimeout(timeout)\n        cvReady = true\n        resolve()\n      }\n    }, 100)\n    \n    document.head.appendChild(script)\n  })\n  \n  return cvLoadPromise\n}\n\n/**\n * 图像预处理：对比度增强\n */\nfunction enhanceContrast(gray) {\n  const result = new cv.Mat()\n  // CLAHE 对比度受限的自适应直方图均衡化\n  const clahe = new cv.CLAHE(2.0, new cv.Size(8, 8))\n  clahe.apply(gray, result)\n  clahe.delete()\n  return result\n}\n\n/**\n * 图像预处理：自适应二值化\n */\nfunction adaptiveThreshold(gray) {\n  const result = new cv.Mat()\n  cv.adaptiveThreshold(gray, result, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 11, 2)\n  return result\n}\n\n/**\n * 图像预处理：放大\n */\nfunction scaleUp(gray, factor) {\n  const result = new cv.Mat()\n  const newSize = new cv.Size(gray.cols * factor, gray.rows * factor)\n  cv.resize(gray, result, newSize, 0, 0, cv.INTER_CUBIC)\n  return result\n}\n\n/**\n * 图像预处理：锐化\n */\nfunction sharpen(gray) {\n  const result = new cv.Mat()\n  const kernel = cv.matFromArray(3, 3, cv.CV_32F, [\n    0, -1, 0,\n    -1, 5, -1,\n    0, -1, 0\n  ])\n  cv.filter2D(gray, result, -1, kernel)\n  kernel.delete()\n  return result\n}\n\n/**\n * 检测图像中的二维码位置\n * @param {ImageData} imageData - Canvas 的 ImageData 对象\n * @returns {Promise<Object|null>} 检测结果，包含位置信息\n */\nexport async function detectQRCode(imageData) {\n  const matsToDelete = [] // 统一管理需要释放的 Mat\n  \n  try {\n    console.log('[QR检测] 开始检测...')\n    console.log('[QR检测] 图像尺寸:', imageData.width, 'x', imageData.height)\n    \n    // 确保 OpenCV.js 已加载\n    await loadOpenCV()\n    console.log('[QR检测] OpenCV.js 已就绪')\n    \n    // 将 ImageData 转换为 OpenCV Mat\n    const src = cv.matFromImageData(imageData)\n    matsToDelete.push(src)\n    console.log('[QR检测] 原始图像 Mat 创建成功')\n    \n    // 转换为灰度图\n    const gray = new cv.Mat()\n    matsToDelete.push(gray)\n    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY)\n    console.log('[QR检测] 灰度图转换完成')\n    \n    // 创建 QR 码检测器\n    const detector = new cv.QRCodeDetector()\n    \n    // 定义多种检测策略\n    const strategies = [\n      { name: '原图直接检测', scale: 1, process: null },\n      { name: '锐化', scale: 1, process: 'sharpen' },\n      { name: '自适应二值化', scale: 1, process: 'threshold' },\n      { name: '放大2倍', scale: 2, process: null },\n      { name: '放大2倍+锐化', scale: 2, process: 'sharpen' },\n      { name: '放大3倍', scale: 3, process: null },\n      { name: '放大4倍', scale: 4, process: null },\n    ]\n    \n    let result = null\n    \n    for (const strategy of strategies) {\n      console.log(`[QR检测] 尝试策略: ${strategy.name}`)\n      \n      let processed = gray\n      \n      // 放大处理\n      if (strategy.scale > 1) {\n        processed = scaleUp(processed, strategy.scale)\n        matsToDelete.push(processed)\n      }\n      \n      // 额外处理\n      if (strategy.process === 'sharpen') {\n        const sharpened = sharpen(processed)\n        matsToDelete.push(sharpened)\n        processed = sharpened\n      } else if (strategy.process === 'threshold') {\n        const thresholded = adaptiveThreshold(processed)\n        matsToDelete.push(thresholded)\n        processed = thresholded\n      }\n      \n      const points = new cv.Mat()\n      matsToDelete.push(points)\n      \n      const found = detector.detect(processed, points)\n      console.log(`[QR检测] ${strategy.name} - found:`, found, ', points:', points.rows, 'x', points.cols)\n      \n      if (found && points.rows > 0 && points.data32F && points.data32F.length >= 8) {\n        const data = points.data32F\n        console.log('[QR检测] ✓ 检测到二维码!')\n        console.log('[QR检测] 点数据:', Array.from(data).map(v => Math.round(v)))\n        \n        // 根据缩放因子调整坐标\n        const scale = strategy.scale\n        \n        // 四个角点：左上、右上、右下、左下（顺时针）\n        const topLeft = { x: data[0] / scale, y: data[1] / scale }\n        const topRight = { x: data[2] / scale, y: data[3] / scale }\n        const bottomRight = { x: data[4] / scale, y: data[5] / scale }\n        const bottomLeft = { x: data[6] / scale, y: data[7] / scale }\n        \n        const corners = { topLeft, topRight, bottomRight, bottomLeft }\n        \n        result = {\n          topLeft,\n          topRight,\n          bottomRight,\n          bottomLeft,\n          boundingBox: calculateBoundingBox(corners),\n          center: calculateCenter(corners),\n          strategy: strategy.name,\n          allDetections: [{\n            topLeft,\n            topRight,\n            bottomRight,\n            bottomLeft,\n            boundingBox: calculateBoundingBox(corners),\n            center: calculateCenter(corners)\n          }]\n        }\n        \n        // 找到就退出循环\n        break\n      }\n    }\n    \n    detector.delete()\n    \n    if (!result) {\n      console.log('[QR检测] ✗ 所有策略都未检测到二维码')\n    } else {\n      console.log('[QR检测] 检测完成, 使用策略:', result.strategy)\n    }\n    \n    return result\n  } catch (error) {\n    console.error('[QR检测] OpenCV 检测错误:', error)\n    console.error('[QR检测] 错误堆栈:', error.stack)\n    return null\n  } finally {\n    // 清理所有 Mat 对象\n    matsToDelete.forEach(mat => {\n      try {\n        if (mat && !mat.isDeleted()) {\n          mat.delete()\n        }\n      } catch (e) {\n        // 忽略删除错误\n      }\n    })\n  }\n}\n\n/**\n * 计算边界框\n * @param {Object} corners - 四个角点坐标\n * @returns {Object} 边界框 { x, y, width, height }\n */\nfunction calculateBoundingBox(corners) {\n  const { topLeft, topRight, bottomRight, bottomLeft } = corners\n  const points = [topLeft, topRight, bottomRight, bottomLeft]\n  \n  const xs = points.map(p => p.x)\n  const ys = points.map(p => p.y)\n  \n  const minX = Math.min(...xs)\n  const maxX = Math.max(...xs)\n  const minY = Math.min(...ys)\n  const maxY = Math.max(...ys)\n  \n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  }\n}\n\n/**\n * 计算二维码中心点\n * @param {Object} corners - 四个角点坐标\n * @returns {Object} 中心点坐标 { x, y }\n */\nfunction calculateCenter(corners) {\n  const { topLeft, topRight, bottomRight, bottomLeft } = corners\n  \n  return {\n    x: (topLeft.x + topRight.x + bottomRight.x + bottomLeft.x) / 4,\n    y: (topLeft.y + topRight.y + bottomRight.y + bottomLeft.y) / 4\n  }\n}\n\n/**\n * 在 Canvas 上绘制检测结果\n * @param {CanvasRenderingContext2D} ctx - Canvas 2D 上下文\n * @param {Object} detection - 检测结果\n * @param {Object} options - 绘制选项\n */\nexport function drawDetectionResult(ctx, detection, options = {}) {\n  const {\n    fillColor = 'rgba(0, 245, 160, 0.15)',\n    lineWidth = 3,\n    cornerRadius = 8,\n    showCenter = true,\n    showCorners = true\n  } = options\n  \n  // 绘制所有检测到的二维码\n  const detections = detection.allDetections || [detection]\n  \n  detections.forEach((det, index) => {\n    const { topLeft, topRight, bottomRight, bottomLeft, center } = det\n    \n    // 不同二维码用不同颜色\n    const colors = ['#00f5a0', '#ff6b6b', '#4ecdc4', '#ffe66d', '#a855f7']\n    const color = colors[index % colors.length]\n    \n    ctx.save()\n    \n    // 绘制填充区域\n    ctx.fillStyle = fillColor\n    ctx.beginPath()\n    ctx.moveTo(topLeft.x, topLeft.y)\n    ctx.lineTo(topRight.x, topRight.y)\n    ctx.lineTo(bottomRight.x, bottomRight.y)\n    ctx.lineTo(bottomLeft.x, bottomLeft.y)\n    ctx.closePath()\n    ctx.fill()\n    \n    // 绘制边框\n    ctx.strokeStyle = color\n    ctx.lineWidth = lineWidth\n    ctx.lineCap = 'round'\n    ctx.lineJoin = 'round'\n    \n    // 绘制四边形边框\n    ctx.beginPath()\n    ctx.moveTo(topLeft.x, topLeft.y)\n    ctx.lineTo(topRight.x, topRight.y)\n    ctx.lineTo(bottomRight.x, bottomRight.y)\n    ctx.lineTo(bottomLeft.x, bottomLeft.y)\n    ctx.closePath()\n    ctx.stroke()\n    \n    // 绘制角点标记\n    if (showCorners) {\n      const corners = [topLeft, topRight, bottomRight, bottomLeft]\n      ctx.fillStyle = color\n      \n      corners.forEach(corner => {\n        ctx.beginPath()\n        ctx.arc(corner.x, corner.y, cornerRadius, 0, Math.PI * 2)\n        ctx.fill()\n      })\n    }\n    \n    // 绘制中心点\n    if (showCenter) {\n      ctx.fillStyle = color\n      ctx.beginPath()\n      ctx.arc(center.x, center.y, 6, 0, Math.PI * 2)\n      ctx.fill()\n      \n      // 绘制十字线\n      ctx.strokeStyle = color\n      ctx.lineWidth = 2\n      const crossSize = 15\n      \n      ctx.beginPath()\n      ctx.moveTo(center.x - crossSize, center.y)\n      ctx.lineTo(center.x + crossSize, center.y)\n      ctx.moveTo(center.x, center.y - crossSize)\n      ctx.lineTo(center.x, center.y + crossSize)\n      ctx.stroke()\n    }\n    \n    ctx.restore()\n  })\n}\n\n/**\n * 从视频帧获取 ImageData\n * @param {HTMLVideoElement} video - 视频元素\n * @param {HTMLCanvasElement} canvas - Canvas 元素\n * @returns {ImageData|null} ImageData 对象\n */\nexport function getImageDataFromVideo(video, canvas) {\n  if (!video || video.readyState !== video.HAVE_ENOUGH_DATA) {\n    return null\n  }\n  \n  const ctx = canvas.getContext('2d')\n  canvas.width = video.videoWidth\n  canvas.height = video.videoHeight\n  \n  ctx.drawImage(video, 0, 0, canvas.width, canvas.height)\n  \n  return ctx.getImageData(0, 0, canvas.width, canvas.height)\n}\n\n/**\n * 从图片文件获取 ImageData\n * @param {File} file - 图片文件\n * @returns {Promise<{imageData: ImageData, width: number, height: number}>}\n */\nexport function getImageDataFromFile(file) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader()\n    \n    reader.onload = (e) => {\n      const img = new Image()\n      \n      img.onload = () => {\n        const canvas = document.createElement('canvas')\n        canvas.width = img.width\n        canvas.height = img.height\n        \n        const ctx = canvas.getContext('2d')\n        ctx.drawImage(img, 0, 0)\n        \n        const imageData = ctx.getImageData(0, 0, img.width, img.height)\n        \n        resolve({\n          imageData,\n          width: img.width,\n          height: img.height,\n          imageSrc: e.target.result\n        })\n      }\n      \n      img.onerror = () => reject(new Error('图片加载失败'))\n      img.src = e.target.result\n    }\n    \n    reader.onerror = () => reject(new Error('文件读取失败'))\n    reader.readAsDataURL(file)\n  })\n}\n\n/**\n * 预加载 OpenCV.js（可在应用启动时调用）\n * @returns {Promise<void>}\n */\nexport async function preloadOpenCV() {\n  return loadOpenCV()\n}\n\n/**\n * 检查 OpenCV.js 是否已加载\n * @returns {boolean}\n */\nexport function isOpenCVReady() {\n  return cvReady\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}