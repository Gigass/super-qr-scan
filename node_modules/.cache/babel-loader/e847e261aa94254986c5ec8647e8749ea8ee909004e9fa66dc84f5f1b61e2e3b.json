{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\n/**\n * 二维码检测工具模块\n * 使用 OpenCV.js 的 QRCodeDetector.detect() 方法检测二维码位置\n */\n\n// OpenCV.js 加载状态\nlet cvReady = false;\nlet cvLoadPromise = null;\n\n/**\n * 动态加载 OpenCV.js\n * @returns {Promise<void>}\n */\nfunction loadOpenCV() {\n  if (cvReady) {\n    return Promise.resolve();\n  }\n  if (cvLoadPromise) {\n    return cvLoadPromise;\n  }\n  cvLoadPromise = new Promise((resolve, reject) => {\n    // 检查是否已经加载\n    if (typeof cv !== 'undefined' && cv.Mat) {\n      cvReady = true;\n      resolve();\n      return;\n    }\n\n    // 创建 script 标签加载 OpenCV.js\n    const script = document.createElement('script');\n    script.src = 'https://docs.opencv.org/4.8.0/opencv.js';\n    script.async = true;\n\n    // OpenCV.js 加载完成后会调用 onRuntimeInitialized\n    window.Module = {\n      onRuntimeInitialized() {\n        console.log('OpenCV.js 已加载');\n        cvReady = true;\n        resolve();\n      }\n    };\n    script.onerror = () => {\n      reject(new Error('OpenCV.js 加载失败'));\n    };\n\n    // 设置超时\n    const timeout = setTimeout(() => {\n      if (!cvReady) {\n        reject(new Error('OpenCV.js 加载超时'));\n      }\n    }, 30000);\n\n    // 监听 cv 对象就绪\n    const checkReady = setInterval(() => {\n      if (typeof cv !== 'undefined' && cv.Mat) {\n        clearInterval(checkReady);\n        clearTimeout(timeout);\n        cvReady = true;\n        resolve();\n      }\n    }, 100);\n    document.head.appendChild(script);\n  });\n  return cvLoadPromise;\n}\n\n/**\n * 检测图像中的二维码位置\n * @param {ImageData} imageData - Canvas 的 ImageData 对象\n * @returns {Promise<Object|null>} 检测结果，包含位置信息\n */\nexport async function detectQRCode(imageData) {\n  try {\n    // 确保 OpenCV.js 已加载\n    await loadOpenCV();\n\n    // 将 ImageData 转换为 OpenCV Mat\n    const src = cv.matFromImageData(imageData);\n\n    // 转换为灰度图（提高检测率）\n    const gray = new cv.Mat();\n    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);\n\n    // 创建 QR 码检测器\n    const detector = new cv.QRCodeDetector();\n\n    // 创建用于存储检测点的 Mat\n    const points = new cv.Mat();\n\n    // 只检测位置，不解码（使用 detect 而不是 detectAndDecode）\n    const found = detector.detect(gray, points);\n    let result = null;\n    if (found && points.rows > 0) {\n      // 提取四个角点坐标\n      // OpenCV 返回的是 1xN 的 Mat，每4个点为一个二维码\n      const data = points.data32F;\n      if (data.length >= 8) {\n        // 四个角点：左上、右上、右下、左下（顺时针）\n        const topLeft = {\n          x: data[0],\n          y: data[1]\n        };\n        const topRight = {\n          x: data[2],\n          y: data[3]\n        };\n        const bottomRight = {\n          x: data[4],\n          y: data[5]\n        };\n        const bottomLeft = {\n          x: data[6],\n          y: data[7]\n        };\n        const corners = {\n          topLeft,\n          topRight,\n          bottomRight,\n          bottomLeft\n        };\n        result = {\n          topLeft,\n          topRight,\n          bottomRight,\n          bottomLeft,\n          boundingBox: calculateBoundingBox(corners),\n          center: calculateCenter(corners),\n          allDetections: [{\n            topLeft,\n            topRight,\n            bottomRight,\n            bottomLeft,\n            boundingBox: calculateBoundingBox(corners),\n            center: calculateCenter(corners)\n          }]\n        };\n\n        // 如果有多个二维码\n        if (data.length > 8) {\n          const allDetections = [];\n          for (let i = 0; i < data.length; i += 8) {\n            if (i + 7 < data.length) {\n              const tl = {\n                x: data[i],\n                y: data[i + 1]\n              };\n              const tr = {\n                x: data[i + 2],\n                y: data[i + 3]\n              };\n              const br = {\n                x: data[i + 4],\n                y: data[i + 5]\n              };\n              const bl = {\n                x: data[i + 6],\n                y: data[i + 7]\n              };\n              const c = {\n                topLeft: tl,\n                topRight: tr,\n                bottomRight: br,\n                bottomLeft: bl\n              };\n              allDetections.push({\n                topLeft: tl,\n                topRight: tr,\n                bottomRight: br,\n                bottomLeft: bl,\n                boundingBox: calculateBoundingBox(c),\n                center: calculateCenter(c)\n              });\n            }\n          }\n          result.allDetections = allDetections;\n        }\n      }\n    }\n\n    // 清理内存\n    src.delete();\n    gray.delete();\n    points.delete();\n    detector.delete();\n    return result;\n  } catch (error) {\n    console.error('OpenCV 检测错误:', error);\n    return null;\n  }\n}\n\n/**\n * 计算边界框\n * @param {Object} corners - 四个角点坐标\n * @returns {Object} 边界框 { x, y, width, height }\n */\nfunction calculateBoundingBox(corners) {\n  const {\n    topLeft,\n    topRight,\n    bottomRight,\n    bottomLeft\n  } = corners;\n  const points = [topLeft, topRight, bottomRight, bottomLeft];\n  const xs = points.map(p => p.x);\n  const ys = points.map(p => p.y);\n  const minX = Math.min(...xs);\n  const maxX = Math.max(...xs);\n  const minY = Math.min(...ys);\n  const maxY = Math.max(...ys);\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\n\n/**\n * 计算二维码中心点\n * @param {Object} corners - 四个角点坐标\n * @returns {Object} 中心点坐标 { x, y }\n */\nfunction calculateCenter(corners) {\n  const {\n    topLeft,\n    topRight,\n    bottomRight,\n    bottomLeft\n  } = corners;\n  return {\n    x: (topLeft.x + topRight.x + bottomRight.x + bottomLeft.x) / 4,\n    y: (topLeft.y + topRight.y + bottomRight.y + bottomLeft.y) / 4\n  };\n}\n\n/**\n * 在 Canvas 上绘制检测结果\n * @param {CanvasRenderingContext2D} ctx - Canvas 2D 上下文\n * @param {Object} detection - 检测结果\n * @param {Object} options - 绘制选项\n */\nexport function drawDetectionResult(ctx, detection, options = {}) {\n  const {\n    fillColor = 'rgba(0, 245, 160, 0.15)',\n    lineWidth = 3,\n    cornerRadius = 8,\n    showCenter = true,\n    showCorners = true\n  } = options;\n\n  // 绘制所有检测到的二维码\n  const detections = detection.allDetections || [detection];\n  detections.forEach((det, index) => {\n    const {\n      topLeft,\n      topRight,\n      bottomRight,\n      bottomLeft,\n      center\n    } = det;\n\n    // 不同二维码用不同颜色\n    const colors = ['#00f5a0', '#ff6b6b', '#4ecdc4', '#ffe66d', '#a855f7'];\n    const color = colors[index % colors.length];\n    ctx.save();\n\n    // 绘制填充区域\n    ctx.fillStyle = fillColor;\n    ctx.beginPath();\n    ctx.moveTo(topLeft.x, topLeft.y);\n    ctx.lineTo(topRight.x, topRight.y);\n    ctx.lineTo(bottomRight.x, bottomRight.y);\n    ctx.lineTo(bottomLeft.x, bottomLeft.y);\n    ctx.closePath();\n    ctx.fill();\n\n    // 绘制边框\n    ctx.strokeStyle = color;\n    ctx.lineWidth = lineWidth;\n    ctx.lineCap = 'round';\n    ctx.lineJoin = 'round';\n\n    // 绘制四边形边框\n    ctx.beginPath();\n    ctx.moveTo(topLeft.x, topLeft.y);\n    ctx.lineTo(topRight.x, topRight.y);\n    ctx.lineTo(bottomRight.x, bottomRight.y);\n    ctx.lineTo(bottomLeft.x, bottomLeft.y);\n    ctx.closePath();\n    ctx.stroke();\n\n    // 绘制角点标记\n    if (showCorners) {\n      const corners = [topLeft, topRight, bottomRight, bottomLeft];\n      ctx.fillStyle = color;\n      corners.forEach(corner => {\n        ctx.beginPath();\n        ctx.arc(corner.x, corner.y, cornerRadius, 0, Math.PI * 2);\n        ctx.fill();\n      });\n    }\n\n    // 绘制中心点\n    if (showCenter) {\n      ctx.fillStyle = color;\n      ctx.beginPath();\n      ctx.arc(center.x, center.y, 6, 0, Math.PI * 2);\n      ctx.fill();\n\n      // 绘制十字线\n      ctx.strokeStyle = color;\n      ctx.lineWidth = 2;\n      const crossSize = 15;\n      ctx.beginPath();\n      ctx.moveTo(center.x - crossSize, center.y);\n      ctx.lineTo(center.x + crossSize, center.y);\n      ctx.moveTo(center.x, center.y - crossSize);\n      ctx.lineTo(center.x, center.y + crossSize);\n      ctx.stroke();\n    }\n    ctx.restore();\n  });\n}\n\n/**\n * 从视频帧获取 ImageData\n * @param {HTMLVideoElement} video - 视频元素\n * @param {HTMLCanvasElement} canvas - Canvas 元素\n * @returns {ImageData|null} ImageData 对象\n */\nexport function getImageDataFromVideo(video, canvas) {\n  if (!video || video.readyState !== video.HAVE_ENOUGH_DATA) {\n    return null;\n  }\n  const ctx = canvas.getContext('2d');\n  canvas.width = video.videoWidth;\n  canvas.height = video.videoHeight;\n  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n  return ctx.getImageData(0, 0, canvas.width, canvas.height);\n}\n\n/**\n * 从图片文件获取 ImageData\n * @param {File} file - 图片文件\n * @returns {Promise<{imageData: ImageData, width: number, height: number}>}\n */\nexport function getImageDataFromFile(file) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = e => {\n      const img = new Image();\n      img.onload = () => {\n        const canvas = document.createElement('canvas');\n        canvas.width = img.width;\n        canvas.height = img.height;\n        const ctx = canvas.getContext('2d');\n        ctx.drawImage(img, 0, 0);\n        const imageData = ctx.getImageData(0, 0, img.width, img.height);\n        resolve({\n          imageData,\n          width: img.width,\n          height: img.height,\n          imageSrc: e.target.result\n        });\n      };\n      img.onerror = () => reject(new Error('图片加载失败'));\n      img.src = e.target.result;\n    };\n    reader.onerror = () => reject(new Error('文件读取失败'));\n    reader.readAsDataURL(file);\n  });\n}\n\n/**\n * 预加载 OpenCV.js（可在应用启动时调用）\n * @returns {Promise<void>}\n */\nexport async function preloadOpenCV() {\n  return loadOpenCV();\n}\n\n/**\n * 检查 OpenCV.js 是否已加载\n * @returns {boolean}\n */\nexport function isOpenCVReady() {\n  return cvReady;\n}","map":{"version":3,"names":["cvReady","cvLoadPromise","loadOpenCV","Promise","resolve","reject","cv","Mat","script","document","createElement","src","async","window","Module","onRuntimeInitialized","console","log","onerror","Error","timeout","setTimeout","checkReady","setInterval","clearInterval","clearTimeout","head","appendChild","detectQRCode","imageData","matFromImageData","gray","cvtColor","COLOR_RGBA2GRAY","detector","QRCodeDetector","points","found","detect","result","rows","data","data32F","length","topLeft","x","y","topRight","bottomRight","bottomLeft","corners","boundingBox","calculateBoundingBox","center","calculateCenter","allDetections","i","tl","tr","br","bl","c","push","delete","error","xs","map","p","ys","minX","Math","min","maxX","max","minY","maxY","width","height","drawDetectionResult","ctx","detection","options","fillColor","lineWidth","cornerRadius","showCenter","showCorners","detections","forEach","det","index","colors","color","save","fillStyle","beginPath","moveTo","lineTo","closePath","fill","strokeStyle","lineCap","lineJoin","stroke","corner","arc","PI","crossSize","restore","getImageDataFromVideo","video","canvas","readyState","HAVE_ENOUGH_DATA","getContext","videoWidth","videoHeight","drawImage","getImageData","getImageDataFromFile","file","reader","FileReader","onload","e","img","Image","imageSrc","target","readAsDataURL","preloadOpenCV","isOpenCVReady"],"sources":["/Users/gigass/DEVELOP/GitHub/qrcode/src/utils/qrDetector.js"],"sourcesContent":["/**\n * 二维码检测工具模块\n * 使用 OpenCV.js 的 QRCodeDetector.detect() 方法检测二维码位置\n */\n\n// OpenCV.js 加载状态\nlet cvReady = false\nlet cvLoadPromise = null\n\n/**\n * 动态加载 OpenCV.js\n * @returns {Promise<void>}\n */\nfunction loadOpenCV() {\n  if (cvReady) {\n    return Promise.resolve()\n  }\n  \n  if (cvLoadPromise) {\n    return cvLoadPromise\n  }\n  \n  cvLoadPromise = new Promise((resolve, reject) => {\n    // 检查是否已经加载\n    if (typeof cv !== 'undefined' && cv.Mat) {\n      cvReady = true\n      resolve()\n      return\n    }\n    \n    // 创建 script 标签加载 OpenCV.js\n    const script = document.createElement('script')\n    script.src = 'https://docs.opencv.org/4.8.0/opencv.js'\n    script.async = true\n    \n    // OpenCV.js 加载完成后会调用 onRuntimeInitialized\n    window.Module = {\n      onRuntimeInitialized() {\n        console.log('OpenCV.js 已加载')\n        cvReady = true\n        resolve()\n      }\n    }\n    \n    script.onerror = () => {\n      reject(new Error('OpenCV.js 加载失败'))\n    }\n    \n    // 设置超时\n    const timeout = setTimeout(() => {\n      if (!cvReady) {\n        reject(new Error('OpenCV.js 加载超时'))\n      }\n    }, 30000)\n    \n    // 监听 cv 对象就绪\n    const checkReady = setInterval(() => {\n      if (typeof cv !== 'undefined' && cv.Mat) {\n        clearInterval(checkReady)\n        clearTimeout(timeout)\n        cvReady = true\n        resolve()\n      }\n    }, 100)\n    \n    document.head.appendChild(script)\n  })\n  \n  return cvLoadPromise\n}\n\n/**\n * 检测图像中的二维码位置\n * @param {ImageData} imageData - Canvas 的 ImageData 对象\n * @returns {Promise<Object|null>} 检测结果，包含位置信息\n */\nexport async function detectQRCode(imageData) {\n  try {\n    // 确保 OpenCV.js 已加载\n    await loadOpenCV()\n    \n    // 将 ImageData 转换为 OpenCV Mat\n    const src = cv.matFromImageData(imageData)\n    \n    // 转换为灰度图（提高检测率）\n    const gray = new cv.Mat()\n    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY)\n    \n    // 创建 QR 码检测器\n    const detector = new cv.QRCodeDetector()\n    \n    // 创建用于存储检测点的 Mat\n    const points = new cv.Mat()\n    \n    // 只检测位置，不解码（使用 detect 而不是 detectAndDecode）\n    const found = detector.detect(gray, points)\n    \n    let result = null\n    \n    if (found && points.rows > 0) {\n      // 提取四个角点坐标\n      // OpenCV 返回的是 1xN 的 Mat，每4个点为一个二维码\n      const data = points.data32F\n      \n      if (data.length >= 8) {\n        // 四个角点：左上、右上、右下、左下（顺时针）\n        const topLeft = { x: data[0], y: data[1] }\n        const topRight = { x: data[2], y: data[3] }\n        const bottomRight = { x: data[4], y: data[5] }\n        const bottomLeft = { x: data[6], y: data[7] }\n        \n        const corners = { topLeft, topRight, bottomRight, bottomLeft }\n        \n        result = {\n          topLeft,\n          topRight,\n          bottomRight,\n          bottomLeft,\n          boundingBox: calculateBoundingBox(corners),\n          center: calculateCenter(corners),\n          allDetections: [{\n            topLeft,\n            topRight,\n            bottomRight,\n            bottomLeft,\n            boundingBox: calculateBoundingBox(corners),\n            center: calculateCenter(corners)\n          }]\n        }\n        \n        // 如果有多个二维码\n        if (data.length > 8) {\n          const allDetections = []\n          for (let i = 0; i < data.length; i += 8) {\n            if (i + 7 < data.length) {\n              const tl = { x: data[i], y: data[i + 1] }\n              const tr = { x: data[i + 2], y: data[i + 3] }\n              const br = { x: data[i + 4], y: data[i + 5] }\n              const bl = { x: data[i + 6], y: data[i + 7] }\n              const c = { topLeft: tl, topRight: tr, bottomRight: br, bottomLeft: bl }\n              allDetections.push({\n                topLeft: tl,\n                topRight: tr,\n                bottomRight: br,\n                bottomLeft: bl,\n                boundingBox: calculateBoundingBox(c),\n                center: calculateCenter(c)\n              })\n            }\n          }\n          result.allDetections = allDetections\n        }\n      }\n    }\n    \n    // 清理内存\n    src.delete()\n    gray.delete()\n    points.delete()\n    detector.delete()\n    \n    return result\n  } catch (error) {\n    console.error('OpenCV 检测错误:', error)\n    return null\n  }\n}\n\n/**\n * 计算边界框\n * @param {Object} corners - 四个角点坐标\n * @returns {Object} 边界框 { x, y, width, height }\n */\nfunction calculateBoundingBox(corners) {\n  const { topLeft, topRight, bottomRight, bottomLeft } = corners\n  const points = [topLeft, topRight, bottomRight, bottomLeft]\n  \n  const xs = points.map(p => p.x)\n  const ys = points.map(p => p.y)\n  \n  const minX = Math.min(...xs)\n  const maxX = Math.max(...xs)\n  const minY = Math.min(...ys)\n  const maxY = Math.max(...ys)\n  \n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  }\n}\n\n/**\n * 计算二维码中心点\n * @param {Object} corners - 四个角点坐标\n * @returns {Object} 中心点坐标 { x, y }\n */\nfunction calculateCenter(corners) {\n  const { topLeft, topRight, bottomRight, bottomLeft } = corners\n  \n  return {\n    x: (topLeft.x + topRight.x + bottomRight.x + bottomLeft.x) / 4,\n    y: (topLeft.y + topRight.y + bottomRight.y + bottomLeft.y) / 4\n  }\n}\n\n/**\n * 在 Canvas 上绘制检测结果\n * @param {CanvasRenderingContext2D} ctx - Canvas 2D 上下文\n * @param {Object} detection - 检测结果\n * @param {Object} options - 绘制选项\n */\nexport function drawDetectionResult(ctx, detection, options = {}) {\n  const {\n    fillColor = 'rgba(0, 245, 160, 0.15)',\n    lineWidth = 3,\n    cornerRadius = 8,\n    showCenter = true,\n    showCorners = true\n  } = options\n  \n  // 绘制所有检测到的二维码\n  const detections = detection.allDetections || [detection]\n  \n  detections.forEach((det, index) => {\n    const { topLeft, topRight, bottomRight, bottomLeft, center } = det\n    \n    // 不同二维码用不同颜色\n    const colors = ['#00f5a0', '#ff6b6b', '#4ecdc4', '#ffe66d', '#a855f7']\n    const color = colors[index % colors.length]\n    \n    ctx.save()\n    \n    // 绘制填充区域\n    ctx.fillStyle = fillColor\n    ctx.beginPath()\n    ctx.moveTo(topLeft.x, topLeft.y)\n    ctx.lineTo(topRight.x, topRight.y)\n    ctx.lineTo(bottomRight.x, bottomRight.y)\n    ctx.lineTo(bottomLeft.x, bottomLeft.y)\n    ctx.closePath()\n    ctx.fill()\n    \n    // 绘制边框\n    ctx.strokeStyle = color\n    ctx.lineWidth = lineWidth\n    ctx.lineCap = 'round'\n    ctx.lineJoin = 'round'\n    \n    // 绘制四边形边框\n    ctx.beginPath()\n    ctx.moveTo(topLeft.x, topLeft.y)\n    ctx.lineTo(topRight.x, topRight.y)\n    ctx.lineTo(bottomRight.x, bottomRight.y)\n    ctx.lineTo(bottomLeft.x, bottomLeft.y)\n    ctx.closePath()\n    ctx.stroke()\n    \n    // 绘制角点标记\n    if (showCorners) {\n      const corners = [topLeft, topRight, bottomRight, bottomLeft]\n      ctx.fillStyle = color\n      \n      corners.forEach(corner => {\n        ctx.beginPath()\n        ctx.arc(corner.x, corner.y, cornerRadius, 0, Math.PI * 2)\n        ctx.fill()\n      })\n    }\n    \n    // 绘制中心点\n    if (showCenter) {\n      ctx.fillStyle = color\n      ctx.beginPath()\n      ctx.arc(center.x, center.y, 6, 0, Math.PI * 2)\n      ctx.fill()\n      \n      // 绘制十字线\n      ctx.strokeStyle = color\n      ctx.lineWidth = 2\n      const crossSize = 15\n      \n      ctx.beginPath()\n      ctx.moveTo(center.x - crossSize, center.y)\n      ctx.lineTo(center.x + crossSize, center.y)\n      ctx.moveTo(center.x, center.y - crossSize)\n      ctx.lineTo(center.x, center.y + crossSize)\n      ctx.stroke()\n    }\n    \n    ctx.restore()\n  })\n}\n\n/**\n * 从视频帧获取 ImageData\n * @param {HTMLVideoElement} video - 视频元素\n * @param {HTMLCanvasElement} canvas - Canvas 元素\n * @returns {ImageData|null} ImageData 对象\n */\nexport function getImageDataFromVideo(video, canvas) {\n  if (!video || video.readyState !== video.HAVE_ENOUGH_DATA) {\n    return null\n  }\n  \n  const ctx = canvas.getContext('2d')\n  canvas.width = video.videoWidth\n  canvas.height = video.videoHeight\n  \n  ctx.drawImage(video, 0, 0, canvas.width, canvas.height)\n  \n  return ctx.getImageData(0, 0, canvas.width, canvas.height)\n}\n\n/**\n * 从图片文件获取 ImageData\n * @param {File} file - 图片文件\n * @returns {Promise<{imageData: ImageData, width: number, height: number}>}\n */\nexport function getImageDataFromFile(file) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader()\n    \n    reader.onload = (e) => {\n      const img = new Image()\n      \n      img.onload = () => {\n        const canvas = document.createElement('canvas')\n        canvas.width = img.width\n        canvas.height = img.height\n        \n        const ctx = canvas.getContext('2d')\n        ctx.drawImage(img, 0, 0)\n        \n        const imageData = ctx.getImageData(0, 0, img.width, img.height)\n        \n        resolve({\n          imageData,\n          width: img.width,\n          height: img.height,\n          imageSrc: e.target.result\n        })\n      }\n      \n      img.onerror = () => reject(new Error('图片加载失败'))\n      img.src = e.target.result\n    }\n    \n    reader.onerror = () => reject(new Error('文件读取失败'))\n    reader.readAsDataURL(file)\n  })\n}\n\n/**\n * 预加载 OpenCV.js（可在应用启动时调用）\n * @returns {Promise<void>}\n */\nexport async function preloadOpenCV() {\n  return loadOpenCV()\n}\n\n/**\n * 检查 OpenCV.js 是否已加载\n * @returns {boolean}\n */\nexport function isOpenCVReady() {\n  return cvReady\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}