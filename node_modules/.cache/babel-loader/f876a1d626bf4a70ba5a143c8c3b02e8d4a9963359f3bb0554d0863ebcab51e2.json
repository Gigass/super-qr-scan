{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\n/**\n * 二维码检测工具模块\n * 使用 OpenCV.js 的 QRCodeDetector.detect() 方法检测二维码位置\n */\n\n/* global cv */\n\n// OpenCV.js 加载状态\nlet cvReady = false;\nlet cvLoadPromise = null;\n\n/**\n * 动态加载 OpenCV.js\n * @returns {Promise<void>}\n */\nfunction loadOpenCV() {\n  if (cvReady) {\n    return Promise.resolve();\n  }\n  if (cvLoadPromise) {\n    return cvLoadPromise;\n  }\n  cvLoadPromise = new Promise((resolve, reject) => {\n    // 检查是否已经加载\n    if (typeof cv !== 'undefined' && cv.Mat) {\n      cvReady = true;\n      resolve();\n      return;\n    }\n\n    // 创建 script 标签加载 OpenCV.js\n    const script = document.createElement('script');\n    script.src = 'https://docs.opencv.org/4.8.0/opencv.js';\n    script.async = true;\n\n    // OpenCV.js 加载完成后会调用 onRuntimeInitialized\n    window.Module = {\n      onRuntimeInitialized() {\n        console.log('OpenCV.js 已加载');\n        cvReady = true;\n        resolve();\n      }\n    };\n    script.onerror = () => {\n      reject(new Error('OpenCV.js 加载失败'));\n    };\n\n    // 设置超时\n    const timeout = setTimeout(() => {\n      if (!cvReady) {\n        reject(new Error('OpenCV.js 加载超时'));\n      }\n    }, 30000);\n\n    // 监听 cv 对象就绪\n    const checkReady = setInterval(() => {\n      if (typeof cv !== 'undefined' && cv.Mat) {\n        clearInterval(checkReady);\n        clearTimeout(timeout);\n        cvReady = true;\n        resolve();\n      }\n    }, 100);\n    document.head.appendChild(script);\n  });\n  return cvLoadPromise;\n}\n\n/**\n * 检测图像中的二维码位置\n * @param {ImageData} imageData - Canvas 的 ImageData 对象\n * @returns {Promise<Object|null>} 检测结果，包含位置信息\n */\nexport async function detectQRCode(imageData) {\n  try {\n    console.log('[QR检测] 开始检测...');\n    console.log('[QR检测] 图像尺寸:', imageData.width, 'x', imageData.height);\n\n    // 确保 OpenCV.js 已加载\n    await loadOpenCV();\n    console.log('[QR检测] OpenCV.js 已就绪');\n\n    // 将 ImageData 转换为 OpenCV Mat\n    const src = cv.matFromImageData(imageData);\n    console.log('[QR检测] 原始图像 Mat 创建成功, 尺寸:', src.cols, 'x', src.rows, ', 通道:', src.channels());\n\n    // 转换为灰度图（提高检测率）\n    const gray = new cv.Mat();\n    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);\n    console.log('[QR检测] 灰度图转换完成, 尺寸:', gray.cols, 'x', gray.rows);\n\n    // 创建 QR 码检测器\n    const detector = new cv.QRCodeDetector();\n    console.log('[QR检测] QRCodeDetector 已创建');\n\n    // 创建用于存储检测点的 Mat\n    const points = new cv.Mat();\n\n    // 只检测位置，不解码（使用 detect 而不是 detectAndDecode）\n    console.log('[QR检测] 开始调用 detector.detect()...');\n    const found = detector.detect(gray, points);\n    console.log('[QR检测] detect() 返回值:', found);\n    console.log('[QR检测] points.rows:', points.rows, ', points.cols:', points.cols);\n    console.log('[QR检测] points.type():', points.type());\n    let result = null;\n    if (found && points.rows > 0) {\n      // 提取四个角点坐标\n      // OpenCV 返回的是 1xN 的 Mat，每4个点为一个二维码\n      const data = points.data32F;\n      console.log('[QR检测] 检测到二维码! 点数据长度:', data.length);\n      console.log('[QR检测] 原始点数据:', Array.from(data));\n      if (data.length >= 8) {\n        // 四个角点：左上、右上、右下、左下（顺时针）\n        const topLeft = {\n          x: data[0],\n          y: data[1]\n        };\n        const topRight = {\n          x: data[2],\n          y: data[3]\n        };\n        const bottomRight = {\n          x: data[4],\n          y: data[5]\n        };\n        const bottomLeft = {\n          x: data[6],\n          y: data[7]\n        };\n        const corners = {\n          topLeft,\n          topRight,\n          bottomRight,\n          bottomLeft\n        };\n        result = {\n          topLeft,\n          topRight,\n          bottomRight,\n          bottomLeft,\n          boundingBox: calculateBoundingBox(corners),\n          center: calculateCenter(corners),\n          allDetections: [{\n            topLeft,\n            topRight,\n            bottomRight,\n            bottomLeft,\n            boundingBox: calculateBoundingBox(corners),\n            center: calculateCenter(corners)\n          }]\n        };\n\n        // 如果有多个二维码\n        if (data.length > 8) {\n          const allDetections = [];\n          for (let i = 0; i < data.length; i += 8) {\n            if (i + 7 < data.length) {\n              const tl = {\n                x: data[i],\n                y: data[i + 1]\n              };\n              const tr = {\n                x: data[i + 2],\n                y: data[i + 3]\n              };\n              const br = {\n                x: data[i + 4],\n                y: data[i + 5]\n              };\n              const bl = {\n                x: data[i + 6],\n                y: data[i + 7]\n              };\n              const c = {\n                topLeft: tl,\n                topRight: tr,\n                bottomRight: br,\n                bottomLeft: bl\n              };\n              allDetections.push({\n                topLeft: tl,\n                topRight: tr,\n                bottomRight: br,\n                bottomLeft: bl,\n                boundingBox: calculateBoundingBox(c),\n                center: calculateCenter(c)\n              });\n            }\n          }\n          result.allDetections = allDetections;\n        }\n      }\n    } else {\n      console.log('[QR检测] 未检测到二维码');\n      console.log('[QR检测] found:', found, ', points.rows:', points.rows);\n    }\n\n    // 清理内存\n    src.delete();\n    gray.delete();\n    points.delete();\n    detector.delete();\n    console.log('[QR检测] 检测完成, 结果:', result ? '找到二维码' : '未找到');\n    return result;\n  } catch (error) {\n    console.error('[QR检测] OpenCV 检测错误:', error);\n    console.error('[QR检测] 错误堆栈:', error.stack);\n    return null;\n  }\n}\n\n/**\n * 计算边界框\n * @param {Object} corners - 四个角点坐标\n * @returns {Object} 边界框 { x, y, width, height }\n */\nfunction calculateBoundingBox(corners) {\n  const {\n    topLeft,\n    topRight,\n    bottomRight,\n    bottomLeft\n  } = corners;\n  const points = [topLeft, topRight, bottomRight, bottomLeft];\n  const xs = points.map(p => p.x);\n  const ys = points.map(p => p.y);\n  const minX = Math.min(...xs);\n  const maxX = Math.max(...xs);\n  const minY = Math.min(...ys);\n  const maxY = Math.max(...ys);\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\n\n/**\n * 计算二维码中心点\n * @param {Object} corners - 四个角点坐标\n * @returns {Object} 中心点坐标 { x, y }\n */\nfunction calculateCenter(corners) {\n  const {\n    topLeft,\n    topRight,\n    bottomRight,\n    bottomLeft\n  } = corners;\n  return {\n    x: (topLeft.x + topRight.x + bottomRight.x + bottomLeft.x) / 4,\n    y: (topLeft.y + topRight.y + bottomRight.y + bottomLeft.y) / 4\n  };\n}\n\n/**\n * 在 Canvas 上绘制检测结果\n * @param {CanvasRenderingContext2D} ctx - Canvas 2D 上下文\n * @param {Object} detection - 检测结果\n * @param {Object} options - 绘制选项\n */\nexport function drawDetectionResult(ctx, detection, options = {}) {\n  const {\n    fillColor = 'rgba(0, 245, 160, 0.15)',\n    lineWidth = 3,\n    cornerRadius = 8,\n    showCenter = true,\n    showCorners = true\n  } = options;\n\n  // 绘制所有检测到的二维码\n  const detections = detection.allDetections || [detection];\n  detections.forEach((det, index) => {\n    const {\n      topLeft,\n      topRight,\n      bottomRight,\n      bottomLeft,\n      center\n    } = det;\n\n    // 不同二维码用不同颜色\n    const colors = ['#00f5a0', '#ff6b6b', '#4ecdc4', '#ffe66d', '#a855f7'];\n    const color = colors[index % colors.length];\n    ctx.save();\n\n    // 绘制填充区域\n    ctx.fillStyle = fillColor;\n    ctx.beginPath();\n    ctx.moveTo(topLeft.x, topLeft.y);\n    ctx.lineTo(topRight.x, topRight.y);\n    ctx.lineTo(bottomRight.x, bottomRight.y);\n    ctx.lineTo(bottomLeft.x, bottomLeft.y);\n    ctx.closePath();\n    ctx.fill();\n\n    // 绘制边框\n    ctx.strokeStyle = color;\n    ctx.lineWidth = lineWidth;\n    ctx.lineCap = 'round';\n    ctx.lineJoin = 'round';\n\n    // 绘制四边形边框\n    ctx.beginPath();\n    ctx.moveTo(topLeft.x, topLeft.y);\n    ctx.lineTo(topRight.x, topRight.y);\n    ctx.lineTo(bottomRight.x, bottomRight.y);\n    ctx.lineTo(bottomLeft.x, bottomLeft.y);\n    ctx.closePath();\n    ctx.stroke();\n\n    // 绘制角点标记\n    if (showCorners) {\n      const corners = [topLeft, topRight, bottomRight, bottomLeft];\n      ctx.fillStyle = color;\n      corners.forEach(corner => {\n        ctx.beginPath();\n        ctx.arc(corner.x, corner.y, cornerRadius, 0, Math.PI * 2);\n        ctx.fill();\n      });\n    }\n\n    // 绘制中心点\n    if (showCenter) {\n      ctx.fillStyle = color;\n      ctx.beginPath();\n      ctx.arc(center.x, center.y, 6, 0, Math.PI * 2);\n      ctx.fill();\n\n      // 绘制十字线\n      ctx.strokeStyle = color;\n      ctx.lineWidth = 2;\n      const crossSize = 15;\n      ctx.beginPath();\n      ctx.moveTo(center.x - crossSize, center.y);\n      ctx.lineTo(center.x + crossSize, center.y);\n      ctx.moveTo(center.x, center.y - crossSize);\n      ctx.lineTo(center.x, center.y + crossSize);\n      ctx.stroke();\n    }\n    ctx.restore();\n  });\n}\n\n/**\n * 从视频帧获取 ImageData\n * @param {HTMLVideoElement} video - 视频元素\n * @param {HTMLCanvasElement} canvas - Canvas 元素\n * @returns {ImageData|null} ImageData 对象\n */\nexport function getImageDataFromVideo(video, canvas) {\n  if (!video || video.readyState !== video.HAVE_ENOUGH_DATA) {\n    return null;\n  }\n  const ctx = canvas.getContext('2d');\n  canvas.width = video.videoWidth;\n  canvas.height = video.videoHeight;\n  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n  return ctx.getImageData(0, 0, canvas.width, canvas.height);\n}\n\n/**\n * 从图片文件获取 ImageData\n * @param {File} file - 图片文件\n * @returns {Promise<{imageData: ImageData, width: number, height: number}>}\n */\nexport function getImageDataFromFile(file) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = e => {\n      const img = new Image();\n      img.onload = () => {\n        const canvas = document.createElement('canvas');\n        canvas.width = img.width;\n        canvas.height = img.height;\n        const ctx = canvas.getContext('2d');\n        ctx.drawImage(img, 0, 0);\n        const imageData = ctx.getImageData(0, 0, img.width, img.height);\n        resolve({\n          imageData,\n          width: img.width,\n          height: img.height,\n          imageSrc: e.target.result\n        });\n      };\n      img.onerror = () => reject(new Error('图片加载失败'));\n      img.src = e.target.result;\n    };\n    reader.onerror = () => reject(new Error('文件读取失败'));\n    reader.readAsDataURL(file);\n  });\n}\n\n/**\n * 预加载 OpenCV.js（可在应用启动时调用）\n * @returns {Promise<void>}\n */\nexport async function preloadOpenCV() {\n  return loadOpenCV();\n}\n\n/**\n * 检查 OpenCV.js 是否已加载\n * @returns {boolean}\n */\nexport function isOpenCVReady() {\n  return cvReady;\n}","map":{"version":3,"names":["cvReady","cvLoadPromise","loadOpenCV","Promise","resolve","reject","cv","Mat","script","document","createElement","src","async","window","Module","onRuntimeInitialized","console","log","onerror","Error","timeout","setTimeout","checkReady","setInterval","clearInterval","clearTimeout","head","appendChild","detectQRCode","imageData","width","height","matFromImageData","cols","rows","channels","gray","cvtColor","COLOR_RGBA2GRAY","detector","QRCodeDetector","points","found","detect","type","result","data","data32F","length","Array","from","topLeft","x","y","topRight","bottomRight","bottomLeft","corners","boundingBox","calculateBoundingBox","center","calculateCenter","allDetections","i","tl","tr","br","bl","c","push","delete","error","stack","xs","map","p","ys","minX","Math","min","maxX","max","minY","maxY","drawDetectionResult","ctx","detection","options","fillColor","lineWidth","cornerRadius","showCenter","showCorners","detections","forEach","det","index","colors","color","save","fillStyle","beginPath","moveTo","lineTo","closePath","fill","strokeStyle","lineCap","lineJoin","stroke","corner","arc","PI","crossSize","restore","getImageDataFromVideo","video","canvas","readyState","HAVE_ENOUGH_DATA","getContext","videoWidth","videoHeight","drawImage","getImageData","getImageDataFromFile","file","reader","FileReader","onload","e","img","Image","imageSrc","target","readAsDataURL","preloadOpenCV","isOpenCVReady"],"sources":["/Users/gigass/DEVELOP/GitHub/qrcode/src/utils/qrDetector.js"],"sourcesContent":["/**\n * 二维码检测工具模块\n * 使用 OpenCV.js 的 QRCodeDetector.detect() 方法检测二维码位置\n */\n\n/* global cv */\n\n// OpenCV.js 加载状态\nlet cvReady = false\nlet cvLoadPromise = null\n\n/**\n * 动态加载 OpenCV.js\n * @returns {Promise<void>}\n */\nfunction loadOpenCV() {\n  if (cvReady) {\n    return Promise.resolve()\n  }\n  \n  if (cvLoadPromise) {\n    return cvLoadPromise\n  }\n  \n  cvLoadPromise = new Promise((resolve, reject) => {\n    // 检查是否已经加载\n    if (typeof cv !== 'undefined' && cv.Mat) {\n      cvReady = true\n      resolve()\n      return\n    }\n    \n    // 创建 script 标签加载 OpenCV.js\n    const script = document.createElement('script')\n    script.src = 'https://docs.opencv.org/4.8.0/opencv.js'\n    script.async = true\n    \n    // OpenCV.js 加载完成后会调用 onRuntimeInitialized\n    window.Module = {\n      onRuntimeInitialized() {\n        console.log('OpenCV.js 已加载')\n        cvReady = true\n        resolve()\n      }\n    }\n    \n    script.onerror = () => {\n      reject(new Error('OpenCV.js 加载失败'))\n    }\n    \n    // 设置超时\n    const timeout = setTimeout(() => {\n      if (!cvReady) {\n        reject(new Error('OpenCV.js 加载超时'))\n      }\n    }, 30000)\n    \n    // 监听 cv 对象就绪\n    const checkReady = setInterval(() => {\n      if (typeof cv !== 'undefined' && cv.Mat) {\n        clearInterval(checkReady)\n        clearTimeout(timeout)\n        cvReady = true\n        resolve()\n      }\n    }, 100)\n    \n    document.head.appendChild(script)\n  })\n  \n  return cvLoadPromise\n}\n\n/**\n * 检测图像中的二维码位置\n * @param {ImageData} imageData - Canvas 的 ImageData 对象\n * @returns {Promise<Object|null>} 检测结果，包含位置信息\n */\nexport async function detectQRCode(imageData) {\n  try {\n    console.log('[QR检测] 开始检测...')\n    console.log('[QR检测] 图像尺寸:', imageData.width, 'x', imageData.height)\n    \n    // 确保 OpenCV.js 已加载\n    await loadOpenCV()\n    console.log('[QR检测] OpenCV.js 已就绪')\n    \n    // 将 ImageData 转换为 OpenCV Mat\n    const src = cv.matFromImageData(imageData)\n    console.log('[QR检测] 原始图像 Mat 创建成功, 尺寸:', src.cols, 'x', src.rows, ', 通道:', src.channels())\n    \n    // 转换为灰度图（提高检测率）\n    const gray = new cv.Mat()\n    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY)\n    console.log('[QR检测] 灰度图转换完成, 尺寸:', gray.cols, 'x', gray.rows)\n    \n    // 创建 QR 码检测器\n    const detector = new cv.QRCodeDetector()\n    console.log('[QR检测] QRCodeDetector 已创建')\n    \n    // 创建用于存储检测点的 Mat\n    const points = new cv.Mat()\n    \n    // 只检测位置，不解码（使用 detect 而不是 detectAndDecode）\n    console.log('[QR检测] 开始调用 detector.detect()...')\n    const found = detector.detect(gray, points)\n    \n    console.log('[QR检测] detect() 返回值:', found)\n    console.log('[QR检测] points.rows:', points.rows, ', points.cols:', points.cols)\n    console.log('[QR检测] points.type():', points.type())\n    \n    let result = null\n    \n    if (found && points.rows > 0) {\n      // 提取四个角点坐标\n      // OpenCV 返回的是 1xN 的 Mat，每4个点为一个二维码\n      const data = points.data32F\n      console.log('[QR检测] 检测到二维码! 点数据长度:', data.length)\n      console.log('[QR检测] 原始点数据:', Array.from(data))\n      \n      if (data.length >= 8) {\n        // 四个角点：左上、右上、右下、左下（顺时针）\n        const topLeft = { x: data[0], y: data[1] }\n        const topRight = { x: data[2], y: data[3] }\n        const bottomRight = { x: data[4], y: data[5] }\n        const bottomLeft = { x: data[6], y: data[7] }\n        \n        const corners = { topLeft, topRight, bottomRight, bottomLeft }\n        \n        result = {\n          topLeft,\n          topRight,\n          bottomRight,\n          bottomLeft,\n          boundingBox: calculateBoundingBox(corners),\n          center: calculateCenter(corners),\n          allDetections: [{\n            topLeft,\n            topRight,\n            bottomRight,\n            bottomLeft,\n            boundingBox: calculateBoundingBox(corners),\n            center: calculateCenter(corners)\n          }]\n        }\n        \n        // 如果有多个二维码\n        if (data.length > 8) {\n          const allDetections = []\n          for (let i = 0; i < data.length; i += 8) {\n            if (i + 7 < data.length) {\n              const tl = { x: data[i], y: data[i + 1] }\n              const tr = { x: data[i + 2], y: data[i + 3] }\n              const br = { x: data[i + 4], y: data[i + 5] }\n              const bl = { x: data[i + 6], y: data[i + 7] }\n              const c = { topLeft: tl, topRight: tr, bottomRight: br, bottomLeft: bl }\n              allDetections.push({\n                topLeft: tl,\n                topRight: tr,\n                bottomRight: br,\n                bottomLeft: bl,\n                boundingBox: calculateBoundingBox(c),\n                center: calculateCenter(c)\n              })\n            }\n          }\n          result.allDetections = allDetections\n        }\n      }\n    } else {\n      console.log('[QR检测] 未检测到二维码')\n      console.log('[QR检测] found:', found, ', points.rows:', points.rows)\n    }\n    \n    // 清理内存\n    src.delete()\n    gray.delete()\n    points.delete()\n    detector.delete()\n    \n    console.log('[QR检测] 检测完成, 结果:', result ? '找到二维码' : '未找到')\n    return result\n  } catch (error) {\n    console.error('[QR检测] OpenCV 检测错误:', error)\n    console.error('[QR检测] 错误堆栈:', error.stack)\n    return null\n  }\n}\n\n/**\n * 计算边界框\n * @param {Object} corners - 四个角点坐标\n * @returns {Object} 边界框 { x, y, width, height }\n */\nfunction calculateBoundingBox(corners) {\n  const { topLeft, topRight, bottomRight, bottomLeft } = corners\n  const points = [topLeft, topRight, bottomRight, bottomLeft]\n  \n  const xs = points.map(p => p.x)\n  const ys = points.map(p => p.y)\n  \n  const minX = Math.min(...xs)\n  const maxX = Math.max(...xs)\n  const minY = Math.min(...ys)\n  const maxY = Math.max(...ys)\n  \n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  }\n}\n\n/**\n * 计算二维码中心点\n * @param {Object} corners - 四个角点坐标\n * @returns {Object} 中心点坐标 { x, y }\n */\nfunction calculateCenter(corners) {\n  const { topLeft, topRight, bottomRight, bottomLeft } = corners\n  \n  return {\n    x: (topLeft.x + topRight.x + bottomRight.x + bottomLeft.x) / 4,\n    y: (topLeft.y + topRight.y + bottomRight.y + bottomLeft.y) / 4\n  }\n}\n\n/**\n * 在 Canvas 上绘制检测结果\n * @param {CanvasRenderingContext2D} ctx - Canvas 2D 上下文\n * @param {Object} detection - 检测结果\n * @param {Object} options - 绘制选项\n */\nexport function drawDetectionResult(ctx, detection, options = {}) {\n  const {\n    fillColor = 'rgba(0, 245, 160, 0.15)',\n    lineWidth = 3,\n    cornerRadius = 8,\n    showCenter = true,\n    showCorners = true\n  } = options\n  \n  // 绘制所有检测到的二维码\n  const detections = detection.allDetections || [detection]\n  \n  detections.forEach((det, index) => {\n    const { topLeft, topRight, bottomRight, bottomLeft, center } = det\n    \n    // 不同二维码用不同颜色\n    const colors = ['#00f5a0', '#ff6b6b', '#4ecdc4', '#ffe66d', '#a855f7']\n    const color = colors[index % colors.length]\n    \n    ctx.save()\n    \n    // 绘制填充区域\n    ctx.fillStyle = fillColor\n    ctx.beginPath()\n    ctx.moveTo(topLeft.x, topLeft.y)\n    ctx.lineTo(topRight.x, topRight.y)\n    ctx.lineTo(bottomRight.x, bottomRight.y)\n    ctx.lineTo(bottomLeft.x, bottomLeft.y)\n    ctx.closePath()\n    ctx.fill()\n    \n    // 绘制边框\n    ctx.strokeStyle = color\n    ctx.lineWidth = lineWidth\n    ctx.lineCap = 'round'\n    ctx.lineJoin = 'round'\n    \n    // 绘制四边形边框\n    ctx.beginPath()\n    ctx.moveTo(topLeft.x, topLeft.y)\n    ctx.lineTo(topRight.x, topRight.y)\n    ctx.lineTo(bottomRight.x, bottomRight.y)\n    ctx.lineTo(bottomLeft.x, bottomLeft.y)\n    ctx.closePath()\n    ctx.stroke()\n    \n    // 绘制角点标记\n    if (showCorners) {\n      const corners = [topLeft, topRight, bottomRight, bottomLeft]\n      ctx.fillStyle = color\n      \n      corners.forEach(corner => {\n        ctx.beginPath()\n        ctx.arc(corner.x, corner.y, cornerRadius, 0, Math.PI * 2)\n        ctx.fill()\n      })\n    }\n    \n    // 绘制中心点\n    if (showCenter) {\n      ctx.fillStyle = color\n      ctx.beginPath()\n      ctx.arc(center.x, center.y, 6, 0, Math.PI * 2)\n      ctx.fill()\n      \n      // 绘制十字线\n      ctx.strokeStyle = color\n      ctx.lineWidth = 2\n      const crossSize = 15\n      \n      ctx.beginPath()\n      ctx.moveTo(center.x - crossSize, center.y)\n      ctx.lineTo(center.x + crossSize, center.y)\n      ctx.moveTo(center.x, center.y - crossSize)\n      ctx.lineTo(center.x, center.y + crossSize)\n      ctx.stroke()\n    }\n    \n    ctx.restore()\n  })\n}\n\n/**\n * 从视频帧获取 ImageData\n * @param {HTMLVideoElement} video - 视频元素\n * @param {HTMLCanvasElement} canvas - Canvas 元素\n * @returns {ImageData|null} ImageData 对象\n */\nexport function getImageDataFromVideo(video, canvas) {\n  if (!video || video.readyState !== video.HAVE_ENOUGH_DATA) {\n    return null\n  }\n  \n  const ctx = canvas.getContext('2d')\n  canvas.width = video.videoWidth\n  canvas.height = video.videoHeight\n  \n  ctx.drawImage(video, 0, 0, canvas.width, canvas.height)\n  \n  return ctx.getImageData(0, 0, canvas.width, canvas.height)\n}\n\n/**\n * 从图片文件获取 ImageData\n * @param {File} file - 图片文件\n * @returns {Promise<{imageData: ImageData, width: number, height: number}>}\n */\nexport function getImageDataFromFile(file) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader()\n    \n    reader.onload = (e) => {\n      const img = new Image()\n      \n      img.onload = () => {\n        const canvas = document.createElement('canvas')\n        canvas.width = img.width\n        canvas.height = img.height\n        \n        const ctx = canvas.getContext('2d')\n        ctx.drawImage(img, 0, 0)\n        \n        const imageData = ctx.getImageData(0, 0, img.width, img.height)\n        \n        resolve({\n          imageData,\n          width: img.width,\n          height: img.height,\n          imageSrc: e.target.result\n        })\n      }\n      \n      img.onerror = () => reject(new Error('图片加载失败'))\n      img.src = e.target.result\n    }\n    \n    reader.onerror = () => reject(new Error('文件读取失败'))\n    reader.readAsDataURL(file)\n  })\n}\n\n/**\n * 预加载 OpenCV.js（可在应用启动时调用）\n * @returns {Promise<void>}\n */\nexport async function preloadOpenCV() {\n  return loadOpenCV()\n}\n\n/**\n * 检查 OpenCV.js 是否已加载\n * @returns {boolean}\n */\nexport function isOpenCVReady() {\n  return cvReady\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}