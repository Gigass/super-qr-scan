[{"/Users/gigass/DEVELOP/GitHub/qrcode/src/main.js":"1","/Users/gigass/DEVELOP/GitHub/qrcode/src/App.vue":"2","/Users/gigass/DEVELOP/GitHub/qrcode/src/utils/qrDetector.js":"3"},{"size":136,"mtime":1768549660662,"results":"4","hashOfConfig":"5"},{"size":26748,"mtime":1768550324779,"results":"6","hashOfConfig":"5"},{"size":7118,"mtime":1768550282535,"results":"7","hashOfConfig":"5"},{"filePath":"8","messages":"9","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"3l0hna",{"filePath":"10","messages":"11","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"12","messages":"13","errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"14"},"/Users/gigass/DEVELOP/GitHub/qrcode/src/main.js",[],"/Users/gigass/DEVELOP/GitHub/qrcode/src/App.vue",[],"/Users/gigass/DEVELOP/GitHub/qrcode/src/utils/qrDetector.js",["15"],"/**\n * 二维码检测工具模块\n * 使用 ZXing-wasm 库检测图像中的二维码位置\n */\nimport { readBarcodesFromImageData, setZXingModuleOverrides } from '@aspect/zxing-wasm/reader'\n\n// 配置 ZXing WASM 模块路径\nsetZXingModuleOverrides({\n  locateFile: (path, prefix) => {\n    if (path.endsWith('.wasm')) {\n      return `https://unpkg.com/@aspect/zxing-wasm@0.2.0/dist/reader/${path}`\n    }\n    return prefix + path\n  }\n})\n\n/**\n * 检测图像中的二维码位置\n * @param {ImageData} imageData - Canvas 的 ImageData 对象\n * @returns {Promise<Object|null>} 检测结果，包含位置信息\n */\nexport async function detectQRCode(imageData) {\n  try {\n    // 使用 ZXing 检测二维码\n    const results = await readBarcodesFromImageData(imageData, {\n      tryHarder: true,        // 更努力地检测（包括模糊/倾斜的码）\n      formats: ['QRCode'],    // 只检测二维码\n      maxNumberOfSymbols: 10  // 最多检测10个二维码\n    })\n    \n    if (!results || results.length === 0) {\n      return null\n    }\n    \n    // 处理所有检测到的二维码\n    const detections = results.map(result => {\n      const { position } = result\n      \n      // ZXing 返回的是 position 对象，包含四个角点\n      // position.topLeft, position.topRight, position.bottomRight, position.bottomLeft\n      const topLeft = { x: position.topLeft.x, y: position.topLeft.y }\n      const topRight = { x: position.topRight.x, y: position.topRight.y }\n      const bottomRight = { x: position.bottomRight.x, y: position.bottomRight.y }\n      const bottomLeft = { x: position.bottomLeft.x, y: position.bottomLeft.y }\n      \n      return {\n        topLeft,\n        topRight,\n        bottomRight,\n        bottomLeft,\n        boundingBox: calculateBoundingBox({ topLeft, topRight, bottomRight, bottomLeft }),\n        center: calculateCenter({ topLeft, topRight, bottomRight, bottomLeft })\n      }\n    })\n    \n    // 返回第一个检测结果（保持向后兼容）\n    // 同时返回所有结果供需要时使用\n    return {\n      ...detections[0],\n      allDetections: detections\n    }\n  } catch (error) {\n    console.error('ZXing 检测错误:', error)\n    return null\n  }\n}\n\n/**\n * 计算边界框\n * @param {Object} corners - 四个角点坐标\n * @returns {Object} 边界框 { x, y, width, height }\n */\nfunction calculateBoundingBox(corners) {\n  const { topLeft, topRight, bottomRight, bottomLeft } = corners\n  const points = [topLeft, topRight, bottomRight, bottomLeft]\n  \n  const xs = points.map(p => p.x)\n  const ys = points.map(p => p.y)\n  \n  const minX = Math.min(...xs)\n  const maxX = Math.max(...xs)\n  const minY = Math.min(...ys)\n  const maxY = Math.max(...ys)\n  \n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  }\n}\n\n/**\n * 计算二维码中心点\n * @param {Object} corners - 四个角点坐标\n * @returns {Object} 中心点坐标 { x, y }\n */\nfunction calculateCenter(corners) {\n  const { topLeft, bottomRight } = corners\n  \n  return {\n    x: (topLeft.x + bottomRight.x) / 2,\n    y: (topLeft.y + bottomRight.y) / 2\n  }\n}\n\n/**\n * 在 Canvas 上绘制检测结果\n * @param {CanvasRenderingContext2D} ctx - Canvas 2D 上下文\n * @param {Object} detection - 检测结果\n * @param {Object} options - 绘制选项\n */\nexport function drawDetectionResult(ctx, detection, options = {}) {\n  const {\n    strokeColor = '#00f5a0',\n    fillColor = 'rgba(0, 245, 160, 0.15)',\n    lineWidth = 3,\n    cornerRadius = 8,\n    showCenter = true,\n    showCorners = true\n  } = options\n  \n  // 绘制所有检测到的二维码\n  const detections = detection.allDetections || [detection]\n  \n  detections.forEach((det, index) => {\n    const { topLeft, topRight, bottomRight, bottomLeft, center } = det\n    \n    // 不同二维码用不同颜色\n    const colors = ['#00f5a0', '#ff6b6b', '#4ecdc4', '#ffe66d', '#a855f7']\n    const color = colors[index % colors.length]\n    \n    ctx.save()\n    \n    // 绘制填充区域\n    ctx.fillStyle = fillColor\n    ctx.beginPath()\n    ctx.moveTo(topLeft.x, topLeft.y)\n    ctx.lineTo(topRight.x, topRight.y)\n    ctx.lineTo(bottomRight.x, bottomRight.y)\n    ctx.lineTo(bottomLeft.x, bottomLeft.y)\n    ctx.closePath()\n    ctx.fill()\n    \n    // 绘制边框\n    ctx.strokeStyle = color\n    ctx.lineWidth = lineWidth\n    ctx.lineCap = 'round'\n    ctx.lineJoin = 'round'\n    \n    // 绘制四边形边框\n    ctx.beginPath()\n    ctx.moveTo(topLeft.x, topLeft.y)\n    ctx.lineTo(topRight.x, topRight.y)\n    ctx.lineTo(bottomRight.x, bottomRight.y)\n    ctx.lineTo(bottomLeft.x, bottomLeft.y)\n    ctx.closePath()\n    ctx.stroke()\n    \n    // 绘制角点标记\n    if (showCorners) {\n      const corners = [topLeft, topRight, bottomRight, bottomLeft]\n      ctx.fillStyle = color\n      \n      corners.forEach(corner => {\n        ctx.beginPath()\n        ctx.arc(corner.x, corner.y, cornerRadius, 0, Math.PI * 2)\n        ctx.fill()\n      })\n    }\n    \n    // 绘制中心点\n    if (showCenter) {\n      ctx.fillStyle = color\n      ctx.beginPath()\n      ctx.arc(center.x, center.y, 6, 0, Math.PI * 2)\n      ctx.fill()\n      \n      // 绘制十字线\n      ctx.strokeStyle = color\n      ctx.lineWidth = 2\n      const crossSize = 15\n      \n      ctx.beginPath()\n      ctx.moveTo(center.x - crossSize, center.y)\n      ctx.lineTo(center.x + crossSize, center.y)\n      ctx.moveTo(center.x, center.y - crossSize)\n      ctx.lineTo(center.x, center.y + crossSize)\n      ctx.stroke()\n    }\n    \n    ctx.restore()\n  })\n}\n\n/**\n * 从视频帧获取 ImageData\n * @param {HTMLVideoElement} video - 视频元素\n * @param {HTMLCanvasElement} canvas - Canvas 元素\n * @returns {ImageData|null} ImageData 对象\n */\nexport function getImageDataFromVideo(video, canvas) {\n  if (!video || video.readyState !== video.HAVE_ENOUGH_DATA) {\n    return null\n  }\n  \n  const ctx = canvas.getContext('2d')\n  canvas.width = video.videoWidth\n  canvas.height = video.videoHeight\n  \n  ctx.drawImage(video, 0, 0, canvas.width, canvas.height)\n  \n  return ctx.getImageData(0, 0, canvas.width, canvas.height)\n}\n\n/**\n * 从图片文件获取 ImageData\n * @param {File} file - 图片文件\n * @returns {Promise<{imageData: ImageData, width: number, height: number}>}\n */\nexport function getImageDataFromFile(file) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader()\n    \n    reader.onload = (e) => {\n      const img = new Image()\n      \n      img.onload = () => {\n        const canvas = document.createElement('canvas')\n        canvas.width = img.width\n        canvas.height = img.height\n        \n        const ctx = canvas.getContext('2d')\n        ctx.drawImage(img, 0, 0)\n        \n        const imageData = ctx.getImageData(0, 0, img.width, img.height)\n        \n        resolve({\n          imageData,\n          width: img.width,\n          height: img.height,\n          imageSrc: e.target.result\n        })\n      }\n      \n      img.onerror = () => reject(new Error('图片加载失败'))\n      img.src = e.target.result\n    }\n    \n    reader.onerror = () => reject(new Error('文件读取失败'))\n    reader.readAsDataURL(file)\n  })\n}\n",{"ruleId":"16","severity":2,"message":"17","line":115,"column":5,"nodeType":"18","messageId":"19","endLine":115,"endColumn":16},"no-unused-vars","'strokeColor' is assigned a value but never used.","Identifier","unusedVar"]