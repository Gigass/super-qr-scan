[{"/Users/gigass/DEVELOP/GitHub/qrcode/src/main.js":"1","/Users/gigass/DEVELOP/GitHub/qrcode/src/App.vue":"2","/Users/gigass/DEVELOP/GitHub/qrcode/src/utils/qrDetector.js":"3"},{"size":136,"mtime":1768549660662,"results":"4","hashOfConfig":"5"},{"size":26905,"mtime":1768552200397,"results":"6","hashOfConfig":"5"},{"size":12251,"mtime":1768552200463,"results":"7","hashOfConfig":"5"},{"filePath":"8","messages":"9","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"10"},"3l0hna",{"filePath":"11","messages":"12","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"13"},{"filePath":"14","messages":"15","errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"16"},"/Users/gigass/DEVELOP/GitHub/qrcode/src/main.js",[],[],"/Users/gigass/DEVELOP/GitHub/qrcode/src/App.vue",[],[],"/Users/gigass/DEVELOP/GitHub/qrcode/src/utils/qrDetector.js",["17"],"/**\n * 二维码检测工具模块\n * 使用 OpenCV.js 的 QRCodeDetector.detect() 方法检测二维码位置\n */\n\n/* global cv */\n\n// OpenCV.js 加载状态\nlet cvReady = false\nlet cvLoadPromise = null\n\n/**\n * 动态加载 OpenCV.js\n * @returns {Promise<void>}\n */\nfunction loadOpenCV() {\n  if (cvReady) {\n    return Promise.resolve()\n  }\n  \n  if (cvLoadPromise) {\n    return cvLoadPromise\n  }\n  \n  cvLoadPromise = new Promise((resolve, reject) => {\n    // 检查是否已经加载\n    if (typeof cv !== 'undefined' && cv.Mat) {\n      cvReady = true\n      resolve()\n      return\n    }\n    \n    // 创建 script 标签加载 OpenCV.js\n    const script = document.createElement('script')\n    script.src = 'https://docs.opencv.org/4.8.0/opencv.js'\n    script.async = true\n    \n    // OpenCV.js 加载完成后会调用 onRuntimeInitialized\n    window.Module = {\n      onRuntimeInitialized() {\n        console.log('OpenCV.js 已加载')\n        cvReady = true\n        resolve()\n      }\n    }\n    \n    script.onerror = () => {\n      reject(new Error('OpenCV.js 加载失败'))\n    }\n    \n    // 设置超时\n    const timeout = setTimeout(() => {\n      if (!cvReady) {\n        reject(new Error('OpenCV.js 加载超时'))\n      }\n    }, 30000)\n    \n    // 监听 cv 对象就绪\n    const checkReady = setInterval(() => {\n      if (typeof cv !== 'undefined' && cv.Mat) {\n        clearInterval(checkReady)\n        clearTimeout(timeout)\n        cvReady = true\n        resolve()\n      }\n    }, 100)\n    \n    document.head.appendChild(script)\n  })\n  \n  return cvLoadPromise\n}\n\n/**\n * 图像预处理：对比度增强\n */\nfunction enhanceContrast(gray) {\n  const result = new cv.Mat()\n  // CLAHE 对比度受限的自适应直方图均衡化\n  const clahe = new cv.CLAHE(2.0, new cv.Size(8, 8))\n  clahe.apply(gray, result)\n  clahe.delete()\n  return result\n}\n\n/**\n * 图像预处理：自适应二值化\n */\nfunction adaptiveThreshold(gray) {\n  const result = new cv.Mat()\n  cv.adaptiveThreshold(gray, result, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 11, 2)\n  return result\n}\n\n/**\n * 图像预处理：放大\n */\nfunction scaleUp(gray, factor) {\n  const result = new cv.Mat()\n  const newSize = new cv.Size(gray.cols * factor, gray.rows * factor)\n  cv.resize(gray, result, newSize, 0, 0, cv.INTER_CUBIC)\n  return result\n}\n\n/**\n * 图像预处理：锐化\n */\nfunction sharpen(gray) {\n  const result = new cv.Mat()\n  const kernel = cv.matFromArray(3, 3, cv.CV_32F, [\n    0, -1, 0,\n    -1, 5, -1,\n    0, -1, 0\n  ])\n  cv.filter2D(gray, result, -1, kernel)\n  kernel.delete()\n  return result\n}\n\n/**\n * 检测图像中的二维码位置\n * @param {ImageData} imageData - Canvas 的 ImageData 对象\n * @returns {Promise<Object|null>} 检测结果，包含位置信息\n */\nexport async function detectQRCode(imageData) {\n  const matsToDelete = [] // 统一管理需要释放的 Mat\n  \n  try {\n    console.log('[QR检测] 开始检测...')\n    console.log('[QR检测] 图像尺寸:', imageData.width, 'x', imageData.height)\n    \n    // 确保 OpenCV.js 已加载\n    await loadOpenCV()\n    console.log('[QR检测] OpenCV.js 已就绪')\n    \n    // 将 ImageData 转换为 OpenCV Mat\n    const src = cv.matFromImageData(imageData)\n    matsToDelete.push(src)\n    console.log('[QR检测] 原始图像 Mat 创建成功')\n    \n    // 转换为灰度图\n    const gray = new cv.Mat()\n    matsToDelete.push(gray)\n    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY)\n    console.log('[QR检测] 灰度图转换完成')\n    \n    // 创建 QR 码检测器\n    const detector = new cv.QRCodeDetector()\n    \n    // 定义多种检测策略\n    const strategies = [\n      { name: '原图直接检测', scale: 1, process: null },\n      { name: '锐化', scale: 1, process: 'sharpen' },\n      { name: '自适应二值化', scale: 1, process: 'threshold' },\n      { name: '放大2倍', scale: 2, process: null },\n      { name: '放大2倍+锐化', scale: 2, process: 'sharpen' },\n      { name: '放大3倍', scale: 3, process: null },\n      { name: '放大4倍', scale: 4, process: null },\n    ]\n    \n    let result = null\n    \n    for (const strategy of strategies) {\n      console.log(`[QR检测] 尝试策略: ${strategy.name}`)\n      \n      let processed = gray\n      \n      // 放大处理\n      if (strategy.scale > 1) {\n        processed = scaleUp(processed, strategy.scale)\n        matsToDelete.push(processed)\n      }\n      \n      // 额外处理\n      if (strategy.process === 'sharpen') {\n        const sharpened = sharpen(processed)\n        matsToDelete.push(sharpened)\n        processed = sharpened\n      } else if (strategy.process === 'threshold') {\n        const thresholded = adaptiveThreshold(processed)\n        matsToDelete.push(thresholded)\n        processed = thresholded\n      }\n      \n      const points = new cv.Mat()\n      matsToDelete.push(points)\n      \n      const found = detector.detect(processed, points)\n      console.log(`[QR检测] ${strategy.name} - found:`, found, ', points:', points.rows, 'x', points.cols)\n      \n      if (found && points.rows > 0 && points.data32F && points.data32F.length >= 8) {\n        const data = points.data32F\n        console.log('[QR检测] ✓ 检测到二维码!')\n        console.log('[QR检测] 点数据:', Array.from(data).map(v => Math.round(v)))\n        \n        // 根据缩放因子调整坐标\n        const scale = strategy.scale\n        \n        // 四个角点：左上、右上、右下、左下（顺时针）\n        const topLeft = { x: data[0] / scale, y: data[1] / scale }\n        const topRight = { x: data[2] / scale, y: data[3] / scale }\n        const bottomRight = { x: data[4] / scale, y: data[5] / scale }\n        const bottomLeft = { x: data[6] / scale, y: data[7] / scale }\n        \n        const corners = { topLeft, topRight, bottomRight, bottomLeft }\n        \n        result = {\n          topLeft,\n          topRight,\n          bottomRight,\n          bottomLeft,\n          boundingBox: calculateBoundingBox(corners),\n          center: calculateCenter(corners),\n          strategy: strategy.name,\n          allDetections: [{\n            topLeft,\n            topRight,\n            bottomRight,\n            bottomLeft,\n            boundingBox: calculateBoundingBox(corners),\n            center: calculateCenter(corners)\n          }]\n        }\n        \n        // 找到就退出循环\n        break\n      }\n    }\n    \n    detector.delete()\n    \n    if (!result) {\n      console.log('[QR检测] ✗ 所有策略都未检测到二维码')\n    } else {\n      console.log('[QR检测] 检测完成, 使用策略:', result.strategy)\n    }\n    \n    return result\n  } catch (error) {\n    console.error('[QR检测] OpenCV 检测错误:', error)\n    console.error('[QR检测] 错误堆栈:', error.stack)\n    return null\n  } finally {\n    // 清理所有 Mat 对象\n    matsToDelete.forEach(mat => {\n      try {\n        if (mat && !mat.isDeleted()) {\n          mat.delete()\n        }\n      } catch (e) {\n        // 忽略删除错误\n      }\n    })\n  }\n}\n\n/**\n * 计算边界框\n * @param {Object} corners - 四个角点坐标\n * @returns {Object} 边界框 { x, y, width, height }\n */\nfunction calculateBoundingBox(corners) {\n  const { topLeft, topRight, bottomRight, bottomLeft } = corners\n  const points = [topLeft, topRight, bottomRight, bottomLeft]\n  \n  const xs = points.map(p => p.x)\n  const ys = points.map(p => p.y)\n  \n  const minX = Math.min(...xs)\n  const maxX = Math.max(...xs)\n  const minY = Math.min(...ys)\n  const maxY = Math.max(...ys)\n  \n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  }\n}\n\n/**\n * 计算二维码中心点\n * @param {Object} corners - 四个角点坐标\n * @returns {Object} 中心点坐标 { x, y }\n */\nfunction calculateCenter(corners) {\n  const { topLeft, topRight, bottomRight, bottomLeft } = corners\n  \n  return {\n    x: (topLeft.x + topRight.x + bottomRight.x + bottomLeft.x) / 4,\n    y: (topLeft.y + topRight.y + bottomRight.y + bottomLeft.y) / 4\n  }\n}\n\n/**\n * 在 Canvas 上绘制检测结果\n * @param {CanvasRenderingContext2D} ctx - Canvas 2D 上下文\n * @param {Object} detection - 检测结果\n * @param {Object} options - 绘制选项\n */\nexport function drawDetectionResult(ctx, detection, options = {}) {\n  const {\n    fillColor = 'rgba(0, 245, 160, 0.15)',\n    lineWidth = 3,\n    cornerRadius = 8,\n    showCenter = true,\n    showCorners = true\n  } = options\n  \n  // 绘制所有检测到的二维码\n  const detections = detection.allDetections || [detection]\n  \n  detections.forEach((det, index) => {\n    const { topLeft, topRight, bottomRight, bottomLeft, center } = det\n    \n    // 不同二维码用不同颜色\n    const colors = ['#00f5a0', '#ff6b6b', '#4ecdc4', '#ffe66d', '#a855f7']\n    const color = colors[index % colors.length]\n    \n    ctx.save()\n    \n    // 绘制填充区域\n    ctx.fillStyle = fillColor\n    ctx.beginPath()\n    ctx.moveTo(topLeft.x, topLeft.y)\n    ctx.lineTo(topRight.x, topRight.y)\n    ctx.lineTo(bottomRight.x, bottomRight.y)\n    ctx.lineTo(bottomLeft.x, bottomLeft.y)\n    ctx.closePath()\n    ctx.fill()\n    \n    // 绘制边框\n    ctx.strokeStyle = color\n    ctx.lineWidth = lineWidth\n    ctx.lineCap = 'round'\n    ctx.lineJoin = 'round'\n    \n    // 绘制四边形边框\n    ctx.beginPath()\n    ctx.moveTo(topLeft.x, topLeft.y)\n    ctx.lineTo(topRight.x, topRight.y)\n    ctx.lineTo(bottomRight.x, bottomRight.y)\n    ctx.lineTo(bottomLeft.x, bottomLeft.y)\n    ctx.closePath()\n    ctx.stroke()\n    \n    // 绘制角点标记\n    if (showCorners) {\n      const corners = [topLeft, topRight, bottomRight, bottomLeft]\n      ctx.fillStyle = color\n      \n      corners.forEach(corner => {\n        ctx.beginPath()\n        ctx.arc(corner.x, corner.y, cornerRadius, 0, Math.PI * 2)\n        ctx.fill()\n      })\n    }\n    \n    // 绘制中心点\n    if (showCenter) {\n      ctx.fillStyle = color\n      ctx.beginPath()\n      ctx.arc(center.x, center.y, 6, 0, Math.PI * 2)\n      ctx.fill()\n      \n      // 绘制十字线\n      ctx.strokeStyle = color\n      ctx.lineWidth = 2\n      const crossSize = 15\n      \n      ctx.beginPath()\n      ctx.moveTo(center.x - crossSize, center.y)\n      ctx.lineTo(center.x + crossSize, center.y)\n      ctx.moveTo(center.x, center.y - crossSize)\n      ctx.lineTo(center.x, center.y + crossSize)\n      ctx.stroke()\n    }\n    \n    ctx.restore()\n  })\n}\n\n/**\n * 从视频帧获取 ImageData\n * @param {HTMLVideoElement} video - 视频元素\n * @param {HTMLCanvasElement} canvas - Canvas 元素\n * @returns {ImageData|null} ImageData 对象\n */\nexport function getImageDataFromVideo(video, canvas) {\n  if (!video || video.readyState !== video.HAVE_ENOUGH_DATA) {\n    return null\n  }\n  \n  const ctx = canvas.getContext('2d')\n  canvas.width = video.videoWidth\n  canvas.height = video.videoHeight\n  \n  ctx.drawImage(video, 0, 0, canvas.width, canvas.height)\n  \n  return ctx.getImageData(0, 0, canvas.width, canvas.height)\n}\n\n/**\n * 从图片文件获取 ImageData\n * @param {File} file - 图片文件\n * @returns {Promise<{imageData: ImageData, width: number, height: number}>}\n */\nexport function getImageDataFromFile(file) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader()\n    \n    reader.onload = (e) => {\n      const img = new Image()\n      \n      img.onload = () => {\n        const canvas = document.createElement('canvas')\n        canvas.width = img.width\n        canvas.height = img.height\n        \n        const ctx = canvas.getContext('2d')\n        ctx.drawImage(img, 0, 0)\n        \n        const imageData = ctx.getImageData(0, 0, img.width, img.height)\n        \n        resolve({\n          imageData,\n          width: img.width,\n          height: img.height,\n          imageSrc: e.target.result\n        })\n      }\n      \n      img.onerror = () => reject(new Error('图片加载失败'))\n      img.src = e.target.result\n    }\n    \n    reader.onerror = () => reject(new Error('文件读取失败'))\n    reader.readAsDataURL(file)\n  })\n}\n\n/**\n * 预加载 OpenCV.js（可在应用启动时调用）\n * @returns {Promise<void>}\n */\nexport async function preloadOpenCV() {\n  return loadOpenCV()\n}\n\n/**\n * 检查 OpenCV.js 是否已加载\n * @returns {boolean}\n */\nexport function isOpenCVReady() {\n  return cvReady\n}\n",{"ruleId":"18","severity":2,"message":"19","line":77,"column":10,"nodeType":"20","messageId":"21","endLine":77,"endColumn":25},"no-unused-vars","'enhanceContrast' is defined but never used.","Identifier","unusedVar"]